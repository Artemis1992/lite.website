# Продолжение темы маршрутизации.

```
Сделаем небольшую правку. открываем файл coolsite/urls.py, мы тут уберем префикс 'people/' который связан с маршрутом нашего приложения и оставим пустую строку.

path('', include('people.urls'))

Теперь у нас все маршруты связанные с этим приложением будут отчитыватся от доменного имени. Например открыв файл people/usrls.py и тут пустой строки связан с функцией предстовления index - 
path('', index), 
Уже будет соответсвовать просто главной страници. Ну а уже такой маршрут будет соответсвовать не как было http://127.0.0.1:8000/people/cats/, а уже просто http://127.0.0.1:8000/cats/.
Давай убедимся в этом. Запусти наш вебсервер. И действительно у нас отработала функция index и мы видем такую строчку 
"Страница приложения people"
А если добавить приставку /cats/ в конце. то отработают "Статьи по категориям". 

```
### Улучшим маршрут и будем выводить разные категории в зависимости от их индекса. К примеру http://127.0.0.1:8000/cats/1/ так будем выводить первую категорию http://127.0.0.1:8000/cats/2/ так вторую и т.д. 
```
Для этого где фармируется наша категория  path('cats/', categories), мы добавим числовой пораметр. Это будет числовой пораметр типа int и имя нашего числового параметра- пусть это будет catid.

path('cats/<int:catid>/', categories),

Теперь как нам этот числовой параметр cats/<int:catid>/ отлавить в этой функции categories. переходим в файл views.py, и в функции categories укажим через запятую после request, catid. Тот самый числовой параметр catid в файле people/urls.py.
Теперь выведим его в строк и у нас получится следующий код. форматирование страки, теги обзаца<p></p> и внутри будем отображать соответсвующие категории.

def categories(request, catid):
    return HttpResponse(f"<h1>Статьи по категориям</h1><p>{catid}</p>")

Теперь на запрос к катигории  http://127.0.0.1:8000/cats/2/ у нас отвечает та же самая categories и дополнительно цифра 2. И есл в мы укажим какую либо другую цифру то она у нас выведится. Ну а если мы не будем указывать никакой цифры то у нас выдаст ошибку Page not found (404). Потому что наш запрос не соответсвует нашему маршруту из файла people/urls.py в строке 
path('cats/<int:catid>/', categories), 
и функции куда мы этот маршрут передали в файле views.py  в функции categories.
return HttpResponse(f"<h1>Статьи по категориям</h1><p>{catid}</p>")

И по мимо типов которые мы указали а именно int то можно указывать и другие типы. они следующие 
str, int, slug, uuid, path.
Мы их все использовать не будем но немного разберем. 
В Django в URL-шаблонах для параметров можно использовать различные типы данных, помимо int. Вот основные типы, которые поддерживаются:

1. str — строка (по умолчанию). Это соответствует любому непустому набору символов.
    path('cats/<str:category>/', categories),

2. slug — строка, состоящая из букв, цифр, подчеркиваний и дефисов.
    path('cats/<slug:category_slug>/', categories),

3. uuid — строка UUID (уникальный идентификатор).
    path('cats/<uuid:cat_uuid>/', categories),

4. path — строка, которая может включать косые черты (/).
    path('cats/<path:subpath>/', categories),

5. int — целое число (уже известный вам тип).
    path('cats/<int:catid>/', categories),
Эти типы данных позволяют гибко настраивать URL-маршруты в зависимости от того, что требуется передавать в представление. На данный момент нам нужен тип slug и в место int в данной строке 
    path('cats/<int:catid>/', categories),
мы поставим slug. 
    path('cats/<slug:cat>/', categories),
И в предстовлении-views.py мы так же изменим на cat. 

def categories(request, cat):
    return HttpResponse(f"<h1>Статьи по категориям</h1><p>{cat}</p>")

Теперь проверяяем. У нас теперь можно вводить и цифры и буквы. кроме кирилицы. http://127.0.0.1:8000/cats/212342fsdfsfs/ 


Использование slug в URL-маршрутах часто является предпочтительным вариантом по нескольким причинам:

1. Человекопонятные URL

    URL-адрес с slug гораздо более понятен и удобен для пользователей. Например:

    С int: example.com/cats/12/ — ничего не говорит о содержимом страницы.
    С slug: example.com/cats/fluffy-kitty/ — сразу ясно, что страница относится к категории или объекту "Fluffy Kitty".
2. SEO (Поисковая оптимизация)
    Поисковые системы, такие как Google, лучше воспринимают URL с описательными словами, что улучшает ранжирование сайта. URL с slug, содержащий ключевые слова, помогает увеличить видимость страницы в поисковых системах. Например, example.com/articles/python-django/ лучше для SEO, чем example.com/articles/42/.

3. Безопасность
    Использование slug скрывает внутренние идентификаторы (ID) объектов. При использовании int злоумышленники могут догадаться о структуре базы данных (например, о том, сколько записей существует), что увеличивает риск атак. В то время как slug не дает таких намеков.

4. Легкость запоминания и использования
    URL с slug проще запомнить и использовать для пользователей. Например:

    example.com/cats/12/ — сложно ассоциировать число с конкретной записью.
    example.com/cats/fluffy-kitty/ — легко запомнить и ввести вручную.
5. Гибкость при изменении данных
    slug более гибок при изменении содержимого сайта. Например, если название категории изменилось, можно просто обновить slug, тогда как изменение int может быть сложнее и менее интуитивным.

Когда использовать int?
    Использование целочисленного идентификатора (int) целесообразно в тех случаях, когда уникальные идентификаторы важны, например, для внутреннего учета в базе данных. Однако с точки зрения пользовательского интерфейса и удобства slug предпочтительнее.

пока что вернем обратно все в целях программы обучения. В дальнейшем мы будем использовать slug.

Если по каким то пречинам таких шаблонов 'cats/<int:catid>/' не достаточно то можно использовать re_path
Вот ссылка на официальную документацию по re_path в Django: https://docs.djangoproject.com/en/5.1/topics/http/urls/

Она позволяет делать все тоже самое но с использованием регулярных выражений к примеру мы можем указать год в виде 4х чисел, тогда маршрут можно описать с помощью такой функции re_path. Перейдем в файл people/urls.py  и пропишим следующую строку.
    re_path(r'^archive/(?P<year>[0-9]{4})/', archive),

В выражении re_path(r'^archive/(?P<year>[0-9]{4})/', archive) происходит следующее:

    1. re_path — это функция, которая использует регулярные выражения для сопоставления URL-адресов.

    2. r'^archive/(?P<year>[0-9]{4})/' — это само регулярное выражение:

        * r перед строкой означает "сырая строка" (raw string), что предотвращает экранирование символов в Python.
        * ^archive/ указывает, что URL должен начинаться с archive/.
        * (?P<year>[0-9]{4}) — это именованная группа. Она:
            * ?P<year> задаёт имя параметра year, который передаётся в функцию представления.
            * [0-9]{4} обозначает, что параметр year должен состоять из 4 цифр.
        * Завершающий / указывает, что URL должен заканчиваться этим символом.
    3. archive — это представление, к которому будет направлен запрос. Значение year будет передано как параметр в это представление.

    Пример: запрос к archive/2023/ вызовет функцию archive, и ей будет передан аргумент year=2023.

    Этот механизм полезен для работы с динамическими URL, например, для архивных страниц с годами.

Так же пропишим в функции archive в файле views.py 

def archive(request, year):
    return HttpResponse(f"<h1>Архив по годам</h1><p>{year}</p>")

Если мы перейдем по ссылки http://127.0.0.1:8000/archive/2023/ то мы получим архив по годам. Ну а если мы укажим вместо 4рех, допустим меньше или больше то у нас выйдет ошибка page not found (404). 

```
## Обработка GET и POST запросов

```
Обработка GET и POST запросов на примере адресов происходит так:

GET-запрос используется, когда клиент (например, браузер) хочет получить информацию. В примере с адресами это может быть запрос для получения информации об адресе по его уникальному идентификатору (id). Клиент отправляет запрос с параметром id, а сервер возвращает данные об этом адресе.

POST-запрос применяется, когда клиент хочет передать на сервер новые данные. В случае с адресами это может быть добавление нового адреса. Клиент отправляет данные (например, улицу, город, почтовый индекс), и сервер сохраняет новый адрес.

Таким образом, GET-запросы используются для получения данных, а POST — для отправки новых данных на сервер.

Пропишим следующую строку в функции ctegories словарь GET. 

def categories(request, catid):
    print(request.GET)
    return HttpResponse(f"<h1>Статьи по категориям</h1><p>{catid}</p>")

Теперь перейдем в браузер и пропишем следующее 
http://127.0.0.1:8000/cats/1/?name=Keyt&type=pop
И в кансоль должн выведен словарь GET И как видим он у нас появился. 

<QueryDict: {'name': ['Keyt'], 'type': ['pop']}>
[28/Sep/2024 20:38:17] "GET /cats/1/?name=Keyt&type=pop HTTP/1.1" 200 55

Прежде чем выводить в консоль проверим есть ли в нем данные. 

def categories(request, catid):
    if(request.GET):
        print(request.GET)  # Выводим параметры в терминал
    return HttpResponse(f"<h1>Статьи по категориям</h1><p>{catid}</p>")

Если условие сработает и будет истенной то, в нашем запросе имеется GET-запрос и тогда мы выведим его. И если запустим нашу веб страницу с запросом 
http://127.0.0.1:8000/cats/1/?name=Keyt&type=pop
то увидим что она отработает так же. 
<QueryDict: {'name': ['Keyt'], 'type': ['pop']}> 
А если сделать просто запрос 
http://127.0.0.1:8000/cats/1/
то уже у нас словарь не выведится потому что GET условие не выполнелось.

```

## Обработка исключений при запросах к серверу
```
Самое распространенное исключение когда идет запрос к несуществующей страницы и сервер возвращает страницу с кодом 404. и если сейчас набрать какой нибудь запрос которого у нас нету то, мы получим page not found (404).
Процесс отладки у нас определяется в файле coolsite/settings.py и есть такя строка DEBUG = True - если значение True  то режим отладки, если Flase(боевой режи) то отладка будет отключена.
Если мы запустим в боевом режиме то у нас выдаст исключение.
CommandError: You must set settings.ALLOWED_HOSTS if DEBUG is False.
Это ошибка указывает на то что у нас не разрешенных хостов. 
В коллекции   ALLOWED_HOSTS = []   у нас нет разрешенных хостов. Тут мы должны указыть хост который разрешен для использования. В данном случае мы используем localhost поэтому напишем такое значение 

ALLOWED_HOSTS = ['127.0.0.1']

теперь пробуем запустить наш сервер и впише в него к примеру так, 
http://127.0.0.1:8000/3к2уа/цук231/
И увидем следущую ошибку.

Not Found
The requested resource was not found on this server.

Мы находимся не в режиме отладки.
Как сделать так чтобы отобразить более внятную информацию. Переходи в фйл coolsite/urls.py и тут мы можем прописать специальный обработчик для страницы 404. Определяем ее так, 

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('people.urls'))
]

handler404 = pageNotFound

Сейчас у нас нет этой функции pageNotFound мы ее добавим в views.py и пропишем нашу функцию. 

from django.http import HttpResponse, HttpResponseNotFound

def pageNotFound(request, exception):
    return HttpResponseNotFound("<h1>Страница не найдена</h1>")

И уже у этой функции должно быть 2 параметра request, exception. exception это обработчик исключений. 
Переходим в браузер обнавим страницу not found  и увидем следующее собщение
Страница не найдена
Эта функция отработала благодаря тому что мы прописали в файле coolsite/urls.py строку handler404 = pageNotFound . Теперь при исключении 404 у нас будет вызыватся функция 'Страница не найдена'. И давайте попробуем сгенерировать исключение 404  в функции archive 

from django.http import HttpResponse, HttpResponseNotFound, Http404

def archive(request, year):
    if int(year) > 2024:
        raise Http404()
    return HttpResponse(f"<h1>Архив по годам</h1><p>{year}</p>")

Теперь когд у нас возникает год больше чем 2024  то генерируется 404 Страница ненеайдена и мы автоматически попадаем в функцию pageNotFound. 
Переходим в браузер и пропишем следующий маршрут 
http://127.0.0.1:8000/archive/2025/
И мы увидем что страница не найдена. а если прописать любой год меньше чем 2024 то страница отобразится.

Обработка исключения при запросах к серверу

handler500 - ошибка сервера;
handler403 - доступ запрещен;
handler400 - невозможно обработать запрос;

и все эти обработчики начинают работать только тогда когда DEBUG установлен на False. 
```
## Создание 301 и 302 редиректов.
**301 - страница перемещена на другой постоянный URL-адрес**
**302 - страница перемещена временно на другой URL-адрес**
```
Подобные редиректы приходится довольно часто использовать при разработки сайтов. Нужно знать как их делать в фреймворке Django. Перейдем в файл views.py и в функции вместо raise Http404() пропишем следующую строку. 

return redirect('/')

redirect('/') данная функция будет указывать куда нам перенапровлтся если год будет больше чем 2024 и так же импортируем redirect.

from django.shortcuts import redirect, render

def archive(request, year):
    if int(year) > 2024:
        return redirect('/')
    return HttpResponse(f"<h1>Архив по годам</h1><p>{year}</p>")

запустим наш сайт и попробуем обнавить его. и мы перешли с страницы с исключением на главную страницу. А в консоли видим что редирект был выполнен с кодом 302 0. Он нам говорит что редирект поменялся временно. 

Но как нам сделат постоянный редирект ?

для этого используется пораметр permanent=True. 
return redirect('/', permanent=True) # Редирект

Переходим на страницу вбиваем следующий запрос 
http://127.0.0.1:8000/archive/2025/
Нас перебросило на главную страницу и код редиректа в консоли поменялся
[29/Sep/2024 13:05:48] "GET /archive/2025/ HTTP/1.1" 301 0
Это значит что поменяла на постоянный URL-адрес. 
Так же, прописывать явно какой то адрес на который  мы перемещаемся это плохая практика(хардкодинг) Представим что если адрес поменялся, шаблон его изменился и получается что везде где используется эта функция мы должны будем везде где используется этот адрес поменть его(соответсвенно где то забудим) и у нас вылезут дополнительные ошибки. И вот чтобы этого небыло в редиректе указывают не явный его адрес а его имя. К примеру определим для главной страницы имя назовем home. И соответсвенно мы должны будем нашему маршруту people/urls.py и у главной страницы в первой строке path('', index), указать через запятую name='home' .  Теперь все будет через этот маршрут работать. И если у нас маршрут поменяется к примеру на home 
path('home/', index, name='home'),
то в адресе у нас тоже изменится теперь на http://127.0.0.1:8000/home/

```
