# Постраничная навигация (Пагинация)
**Пагинация — это способ представления длинных списков данных на сайте, разбивая их на отдельные страницы. Это помогает сделать страницы менее перегруженными и удобными для пользователя.**

**На сайте, например, посты могут представлять собой длинный список, который удобно разбить на отдельные страницы. Важно, чтобы страницы не были слишком большими по объему, и пользователю было удобно ориентироваться в данных списка.**

### Преимущества пагинации:

* **Уменьшение нагрузки на сервер (менее объемные страницы).**

* **Улучшение пользовательского опыта (упрощение навигации).**

## Как реализовать пагинацию в Django?

**Для работы с пагинацией в Django используется класс ```Paginator```. Можно использовать его напрямую или через ```ListView```, который уже встроенно поддерживает пагинацию.**

1. **Документация по пагинации:**

   * **[Pagination Using Django](https://docs.djangoproject.com/en/3.1/topics/pagination): здесь объясняется, как использовать класс Paginator, а также как встроить пагинацию в ListView и обработать пагинацию в шаблонах.**
  
2. **API Пагинатора:**

   * **[Paginator API Reference](https://docs.djangoproject.com/en/3.1/ref/paginator/): в этой ссылке представлена информация о методах и атрибутах класса Paginator, что помогает лучше понять, как его использовать.**


## Использование класса ```Paginator``` в Django

**Класс ```Paginator``` в Django предоставляет удобные методы и свойства для работы с разбивкой данных на страницы.**

**Начало работы**

**Запуск Python-консоли:**
```
>>> python
```
**Импортируем класс ```Paginator```:**
```
>>> from django.core.paginator import Paginator
```
**Создаем список данных для работы:**
```
>>> people = [
...     "Марго Робби", "Джеки Иванко", "Билли Айлиш", "Дуа Липа",
...     "Анджелина Джоли", "Джулия Робертс", "Ума Турман", "Майли Сайрус",
... ]
```
**Создаем экземпляр класса ```Paginator```:**
```
>>> p = Paginator(people, 3)
```

**Здесь:**

* **```people``` — список, с которым будем работать.**
* **```3``` — количество элементов на каждой странице.**
***
***Свойства и методы ```Paginator```***

**Общее количество элементов списка:**

```
>>> p.count
8
```

**Список содержит 8 элементов.**

**Общее количество страниц:**

```
>>> p.num_pages
3
```
**Поскольку 8 элементов делятся на 3, получается 2.6, что округляется до 3 страниц. Далее можно обратиться к специальному итератору ```page_range```, который выдаёт последовательность чисел, соответствующих номерам страниц.**
```
>>> p.page_range
range(1, 4)
```
**К примеру, у нас есть всего 4 страницы. Итератор ```page_range``` выдаёт последовательность чисел, начиная с 1 и до 3, так как верхняя граница не включается в интервал. В результате мы получаем последовательность номеров страниц от 1 до 4.**

**Если необходимо получить данные для определённой страницы или работать с ней, используется метод ```page```. В качестве аргумента передаётся номер страницы, которую нужно получить. Этот метод возвращает объект страницы, с которым можно выполнять дальнейшие действия.**
***
***Работа со страницами***

**Получение данных для первой страницы:**
```
>>> p1 = p.page(1)
```
**Теперь ссылка ```p1``` будет указывать на первую страницу. С этим объектом страницы можно выполнять различные действия. Например, можно получить список объектов, которые принадлежат этой странице.**
```
>>> p1.object_list
['Марго Робби', 'Джеки Иванко', 'Билли Айлиш']
```
***
**Список элементов на первой странице:**

**Следующий метод позволяет определить, существует ли следующая страница. Если она существует, метод возвращает ```True```.**
```
>>> p1.has_next()
True
```
**Проверка существования предыдущей страницы:**
```
>>> p1.has_previous()
False
```
**Предыдущей страницы нет, так как мы находимся на первой.**
***
**Существует метод, который позволяет определить, существует ли разбивка по страницам для данного списка. Если список распределён на несколько страниц, метод возвращает ```True```. В случае, если весь список умещается на одной странице, он вернёт ```False```.**
```
>>> p1.has_other_pages()
True
```
***
**Существует метод, который позволяет определить номер следующей страницы. Если следующая страница есть, метод вернёт её номер. Например, вызов ```p1.next_page_number()``` вернёт ```2```, если текущая страница первая.**
```
>>> p1.next_page_number()
2
```
**Есть аналогичный метод, который позволяет узнать номер предыдущей страницы. Однако, если текущая страница является первой, вызов метода приведёт к выбросу исключения, поскольку предыдущей страницы не существует.**
```
>>> p1.previous_page_number()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
```
***Полезные ссылки для изучения***

* **[Pagination Using Django](https://docs.djangoproject.com/en/5.1/topics/pagination/) — примеры работы с пагинацией, использование в шаблонах и функциях представлений.**

* **[Paginator API Reference](https://docs.djangoproject.com/en/5.1/ref/paginator/) — документация с атрибутами и методами класса ```Paginator```.**


## Пагинация в классе представлений

**В классе представлений ```PeopleHome```, который унаследован от базового класса ```ListView```, пагинация встроена изначально. Чтобы воспользоваться ей, достаточно просто определить атрибут ```paginate_by```, который задает количество элементов, отображаемых на одной странице. В нашем случае указано ```paginate_by = 3```, что означает, что на каждой странице будет отображаться не более 3 элементов.**
```
class PeopleHome(DataMixin, ListView):
    paginate_by = 3  # Количество элементов на одной странице
    model = People  # Модель, из которой будем брать данные
    template_name = "people/index.html"  # Шаблон для отображения
    context_object_name = "posts"  # Имя контекста, которое будет использоваться в шаблоне
```
**При запуске проекта и переходе на страницу, мы увидим, что на одной странице отображается только 3 поста. Если мы укажем другое значение в ```paginate_by```, количество постов будет изменяться соответствующим образом.**

## Пагинация в функции представлений

**Если использовать функции представлений, то нужно будет вручную создать объект пагинатора и передать его в шаблон. Для этого в примере с функцией ```about``` в ```views.py``` используется следующая схема:**

```
def about(request):
    contact_list = People.objects.all()  # Получаем все объекты People
    paginator = Paginator(contact_list, 3)  # Создаем пагинатор с количеством элементов на странице
    page_number = request.GET.get('page')  # Получаем номер текущей страницы из GET-запроса
    page_obj = paginator.get_page(page_number)  # Получаем объекты для текущей страницы
    return render(request, 'people/about.html', {'page_obj': page_obj, "menu": menu, 'title': 'О сайте'})
```
**Здесь мы создаем объект ```Paginator```, указываем количество элементов на странице (3), и получаем номер страницы из параметров запроса (```page```). В методе ```get_page()``` мы получаем текущую страницу, и передаем этот объект в шаблон.**

## Шаблон ```about.html```

**В шаблоне для отображения списка контактов, соответствующих текущей странице, используется коллекция ```page_obj```, которая является частью контекста. Для каждого объекта контакта отображается параграф:**

```
{% extends 'people/base.html' %}

{% block content %}
<h1>{{ title }}</h1>

{% for contact in page_obj %}
    <p>{{ contact }}</p>
{% endfor %}

{% endblock %}
```
**Здесь мы перебираем все объекты на текущей странице с помощью ```for contact in page_obj```, и отображаем каждый объект внутри тега ```<p>```. Когда мы открываем страницу, мы видим 3 элемента, как и ожидалось. Если мы изменим параметр в URL (например, ```?page=2```), то увидим следующие 3 записи. Для этого достаточно в адресной строке заменить номер страницы.**

**Переходим на сайт и проверяем, как все работает. На странице "О сайте" отображаются три рубрики:**

## О сайте
* **Марго Робби**
* **Джеки Иванко**
* **Билли Айлиш**

**Если перейти по следующему GET-запросу http://127.0.0.1:8000/about/?page=2, то мы получим следующие записи:**

## О сайте
* **Дуа Липа**
* **Анджелина Джоли**
* **Джулия Робертс**

**Если изменить параметр на ```page=3```, то перейдем на третью страницу, где будут следующие записи:**

## О сайте
* **Ума Турман**
* **Майли Сайрус**


## Ссылки на страницы

**Чтобы добавить ссылки для навигации по страницам, мы можем использовать ```page_range```, который является итератором, возвращаемым объектом пагинатора. Так же в файле about.html:**

```
{% for contact in page_obj %}
    <p>{{ contact }}</p>
{% endfor %}


<nav>
    <ul>
        {% for p in page_obj.paginator.page_range %}
        <li>
            <a href="?page={{ p }}">{{ p }}</a>
        </li>
        {% endfor %}
    </ul>
</nav>
```
**Здесь мы обращаемся к объекту ```page_obj```, который содержит ссылку на пагинатор, а затем получаем итератор ```page_range``` с помощью ```page_obj.paginator.page_range```. Этот итератор позволяет получить все возможные номера страниц. Для каждого номера создаем ссылку, которая будет вести на соответствующую страницу (например, ```?page=2```). Ссылки будут отображаться в виде списка.**

## Пагинация в классе представлений на главной странице

**Теперь давайте добавим пагинацию на главной странице, в шаблоне ```base.html```. В блоке, отвечающем за вывод контента, мы добавляем следующий код для отображения ссылок на страницы:**
```
<!-- Блок основного текста -->
<div class="content-text">
    {% block content %}
    {% endblock %}

    <nav class="list-pages">
        <ul>
            {% for p in paginator.page_range %}
            <li class="page-num">
                <a href="?page={{ p }}" 
                   class="{% if p == page_obj.number %}page-num-selected{% else %}page-num{% endif %}">
                   {{ p }}
                </a>
            </li>
            {% endfor %}
        </ul>
    </nav>
</div>
```
**Теперь подробно разберем часть кода, которая отвечает за пагинацию.**

### **Тег ```<nav>:```**

* **Тег ```<nav>``` используется для определения блока, содержащего навигацию. В данном случае он будет служить для отображения списка страниц с номерами и активной страницы в виде ссылок.**

* **К этому элементу применяется CSS-класс ```list-pages```, который в дальнейшем используется для стилизации.**

### **Тег ```<ul>```:**

* **Тег ```<ul>``` представляет собой неупорядоченный список (unordered list), в котором мы будем выводить элементы пагинации (страничные ссылки).**

* **В этом списке будет по одному элементу ```<li>``` для каждой страницы, которая доступна для пользователя.**

### **Цикл ```{% for p in paginator.page_range %}```:**

* **Здесь начинается цикл, который проходит по всем страницам пагинации.**

* **```paginator.page_range``` — это объект, предоставляющий все возможные номера страниц для текущего набора данных.**
   
   * **```paginator``` — это объект пагинатора, который передается в шаблон автоматически, когда используется пагинация.**
   
   * **```.page_range``` — это атрибут объекта пагинатора, который возвращает диапазон всех номеров страниц (например, от 1 до 10).**

* **В результате каждый элемент цикла p будет представлять собой номер страницы, который можно использовать для навигации.**

### **Создание элемента списка ```<li>```:**
```
<li class="page-num">
    <a href="?page={{ p }}" 
       class="{% if p == page_obj.number %}page-num-selected{% else %}page-num{% endif %}">
       {{ p }}
    </a>
</li>
```
* **Для каждого номера страницы создается элемент списка ```<li>```. Этот элемент будет представлять собой одну кнопку с номером страницы.**

* **Внутри ```<li>``` находится ссылка ```<a>```, которая ведет на соответствующую страницу.Параметр ```?page={{ p }}``` — это запрос, который добавляется к URL, чтобы указать, на какую страницу нужно перейти (например, ```?page=1```, ```?page=2``` и т.д.).**
  

* **Теперь давайте разберемся, что происходит внутри тега ```<a>```:**

   * **```href="?page={{ p }}```": Этот атрибут указывает URL для перехода на страницу с номером ```p```. Django автоматически подставляет значение переменной ```p```, которая является текущим номером страницы.**

   * **```class="{% if p == page_obj.number %}page-num-selected{% else %}page-num{% endif %}":```**
   * **Это условный оператор, который проверяет, является ли текущий номер страницы (```p```) тем, который отображается на данный момент.**
  
   * **Если ```p``` — это номер текущей страницы, то к ссылке применяется класс ```page-num-selected```. Этот класс обычно используется для выделения текущей страницы, чтобы визуально пользователь знал, на какой странице он находится.**
   
   * **Если же номер страницы не совпадает с текущим (то есть, это не текущая страница), то применяется класс ```page-num```, который будет иметь стандартный стиль.**
* **```{{ p }}```: Внутри тега ```<a>``` выводится сам номер страницы.**

### Закрытие цикла и списка:
* ```{% endfor %}```
* ```</ul>```
* ```</nav>```

* **Цикл ```{% for p in paginator.page_range %}``` заканчивается, после чего закрывается тег ```<ul>```, завершая список страниц.**
* 
* **Закрывается тег ```<nav>```, который завершает раздел с навигацией.**
###  Как это работает:

* **Когда пользователь заходит на страницу, например, на первую, Django передает пагинатор в шаблон.**

* **С помощью объекта ```paginator.page_range``` создается список всех страниц, доступных для навигации.**

* **С каждым номером страницы отображается ссылка, и, если номер совпадает с текущей страницей, он будет выделен другим стилем.**

* **Пользователь может нажимать на номера страниц, чтобы переходить между ними, и URL будет обновляться с параметром ```?page=X```, где ```X``` — это номер страницы.**


***
### **Добавляем оформление для этих ссылок с помощью классов в файл css:**
```
.list-pages {
    text-align: center;
    margin: 20px 0;
}

.list-pages ul {
    margin: 0;
    padding: 0;
    list-style: none;
}

.list-pages ul li {
    display: inline-block;
    margin: 0 10px; /* Расстояние между кнопками */
}

/* Базовые стили для кнопок */
.list-pages a {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 50px;
    height: 50px;
    border: 2px solid #b3c2b9; /* Холодный серо-зеленый цвет для рамки */
    border-radius: 50%; /* Делаем кнопки круглыми */
    background-color: #eaf2ef; /* Светлый серо-зеленый фон */
    color: #4a6057; /* Темно-зеленый текст */
    font-size: 18px;
    text-decoration: none;
    transition: all 0.3s ease; /* Плавный переход */
}

/* Эффект при наведении */
.list-pages a:hover {
    background-color: #d1e3db; /* Более насыщенный серо-зеленый фон */
    border-color: #7da392; /* Тёмно-зеленая рамка */
    color: #325046; /* Ещё более тёмный зеленый текст */
    transform: scale(1.1); /* Лёгкое увеличение */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Тень */
}

/* Стили для текущей страницы */
.list-pages .page-num-selected {
    background-color: #7da392; /* Глубокий серо-зеленый фон */
    border-color: #5b8772; /* Ещё более тёмная рамка */
    color: #fff; /* Белый текст */
    font-weight: bold;
}

.list-pages .page-num-selected:hover {
    background-color: #5b8772; /* Более глубокий серо-зеленый фон */
    box-shadow: 0 4px 8px rgba(91, 135, 114, 0.4); /* Тень в зелёном оттенке */
    transform: none; /* Без увеличения для текущей страницы */
}
```
## Как это работает
1. **Когда мы используем классы представлений, ```ListView``` автоматически передает два объекта в шаблон: сам пагинатор и ```page_obj``` с данными текущей страницы.**

2. **Мы можем использовать ```paginator.page_range``` для создания ссылок на страницы и отображения этих ссылок в шаблоне.**
   
3. **Для текущей страницы добавляется особый класс, чтобы выделить её среди остальных.**

**Когда мы откроем главную страницу или страницу с постами, мы увидим числа страниц и сможем перейти на другие страницы. Если перейти на вторую или третью страницу, данные будут обновляться, и отображаться будут только те посты, которые принадлежат текущей странице.**

**Таким образом, пагинация позволяет удобно разделить большой список объектов на несколько страниц, улучшая пользовательский интерфейс и удобство работы с данными.**

***

**Все работает, как надо, но может возникнуть вопрос: почему тег ```<nav>``` был прописан в базовый шаблон, а не в шаблон ```index.html```, который отвечает за главную страницу? Мы сделали это специально, потому что у нас есть ещё и актрисы, и на этой странице пагинация не отображается, так как она не настроена. Мы планируем сделать это чуть позже. Суть в том, что чтобы избежать дублирования кода, мы поместили пагинацию в базовый шаблон ```base.html```. Так она автоматически будет отображаться на всех страницах, где необходима пагинация, а на тех страницах, где она не нужна, не будет отображаться.**

**Чтобы это реализовать, в файле ```views.py``` у нас есть класс ```PeopleCategory```. Если в нем прописать ```paginate_by = 3```, как в классе ```PeopleHome```, то всё должно работать. Но у нас дублируется код, а это не очень хорошо. Чтобы этого избежать, мы уберем эти строки из классов и пропишем их в классе ```DataMixin```, который находится в файле ```utils.py```. Теперь, где необходимо, пагинация будет отображаться, а дублирование кода будет устранено.**

**Также существует такая ситуация, когда весь контент может отобразиться на одной странице. В этом случае пагинация всё равно будет показываться, даже если она не нужна. Чтобы исправить это, в файле ```utils.py``` в классе ```DataMixin``` в строке ```paginate_by = 3``` можно выставить значение ```30```, и тогда пагинация отобразит, что мы находимся на странице ```1```. Это не очень удобно, и нам нужно от этого избавиться. Для этого мы воспользуемся базовым шаблоном ```base.html``` и пропишем условие:**
```
<!-- Блок основного текста -->
<div class="content-text">
    {% block content %}
    {% endblock %}

    {% if page_obj.has_other_pages %}
    
    <nav class="list-pages">
        <ul>
            {% for p in paginator.page_range %}
            <li class="page-num">
                <a href="?page={{ p }}" 
                   class="{% if p == page_obj.number %}page-num-selected{% else %}page-num{% endif %}">
                   {{ p }}
                </a>
            </li>
            {% endfor %}
        </ul>
    </nav>
    {% endif %}
</div>
```
**Метод ```has_other_pages``` проверяет, есть ли страницы, и если их больше чем одна, возвращает ```True```, иначе ```False```. Мы сделали эту проверку, и если она возвращает ```True```, то пагинация будет отображаться, а если ```False```, то не будет.**

**Теперь, когда количество страниц больше ```1```, пагинация будет отображаться корректно. Но если постов будет очень много, то ссылок будет много, и это не совсем практично. Лучше показывать ограниченное количество ссылок на страницы. Например, можно отображать только несколько ближайших номеров страниц.**

**Для этого в нашем шаблоне есть объект ```page_obj.number```, который указывает на текущую страницу. Мы можем использовать его, чтобы задать диапазон отображаемых номеров страниц, например, от текущей страницы минус 2 до текущей страницы плюс 2. Вот как это можно реализовать:**

**В шаблоне ```base.html```:**

```
<!-- Блок основного текста -->
<div class="content-text">
    {% block content %}
    {% endblock %}

    {% if page_obj.has_other_pages %}
    
    <nav class="list-pages">
        <ul>
            <!-- Ссылка на первую страницу -->
            {% if page_obj.number > 1 %}
            <li class="page-num">
                <a href="?page=1" class="page-num">&larr;</a>
            </li>
            {% endif %}
    
            <!-- Ссылки на страницы в диапазоне ±2 -->
            {% for p in paginator.page_range %}
            {% if p == page_obj.number %}
            <li class="page-num">
                <a href="?page={{ p }}" class="page-num-selected">
                    {{ p }}
                </a>
            </li>
            {% elif p >= page_obj.number|add:-1 and p <= page_obj.number|add:1 %}
            <li class="page-num">
                <a href="?page={{ p }}" class="page-num">
                    {{ p }}
                </a>
            </li>
            {% endif %}
            {% endfor %}
    
            <!-- Ссылка на последнюю страницу -->
            {% if page_obj.number < paginator.num_pages %}
            <li class="page-num">
                <a href="?page={{ paginator.num_pages }}" class="page-num">&rarr;</a>
            </li>
            {% endif %}
        </ul>
    </nav>
    
    {% endif %}

</div>
```
**В этом блоке мы проверяем, если номер страницы равен текущей, то показываем её как выбранную, а если номер страницы попадает в диапазон от текущей страницы минус 1 до текущей страницы плюс 1, то отображаем эту ссылку. Все остальные страницы не показываются. Почему мы не можем просто записать ```-2```? Потому что мы работаем с шаблонами, а не с Python, и такой синтаксис не будет работать, поэтому используем фильтр ```add``` для получения нужных значений.**

**Теперь, когда мы обновим страницу, на главной будет отображаться только 5 ссылок, что выглядит гораздо более практично. Мы также добавили функционал для стрелок в пагинации: теперь можно перейти с последней страницы обратно на первую, используя стрелку ```"←"```.**

*Также добавим таблицу для отображения стрелок:*
```
Направление	        Символ
Влево	            &larr;
Вправо	            &rarr;
Вверх	            &uarr;
Вниз	            &darr;
Двойная влево	    &laquo;
Двойная вправо	    &raquo;
```
**Эти стрелки добавляют удобства при навигации по пагинации, а всё остальное работает по аналогии с предыдущими шагами.**
















































