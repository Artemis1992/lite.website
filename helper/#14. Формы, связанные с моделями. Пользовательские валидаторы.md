**В предыдущей ветке мы познакомились с формами, не связанными с моделями. Мы рассмотрели пример добавления статьи. Конечно, это был несколько искусственный пример, так как добавление нового поста связано с обращением к базе данных. В результате в нашем файле ```forms.py``` возникло дублирование кода, поскольку в классе ```AddPostForm()``` мы повторяли поля, которые нужно было отобразить, а эти поля уже присутствуют в классе ```People()```, нашей модели. Это не является хорошей практикой, поскольку код становится избыточным и трудным для поддержки.**

**Когда форма предполагает тесное взаимодействие с какой-либо моделью, то лучше связать форму напрямую с этой моделью. Сейчас мы рассмотрим, как это сделать.**

## Изменение класса формы в ```forms.py```
**Переходим в файл ```forms.py```. Наш класс ```AddPostForm()``` нужно будет унаследовать от другого базового класса, который называется ```ModelForm```, а не просто от ```Form```. Полная строка будет выглядеть так:**
```
class AddPostForm(forms.ModelForm):
```
**Теперь, в рамках этого класса, мы удалим все данные строчки:**
```
title = forms.CharField(max_length=255, label="Заголовок", widget=forms.TextInput(attrs={"class": "form-input"})) 
slug = forms.SlugField(max_length=255, label="URL")
content = forms.CharField(widget=forms.Textarea(attrs={'cols': 60, 'rows': 10}), label="Контент")
is_published = forms.BooleanField(label="Публикация", required=False, initial=True)
cat = forms.ModelChoiceField(queryset=Category.objects.all(), label="Категории", empty_label="Категория не выбрана")
```
**Теперь мы не будем вручную добавлять эти поля в форму. Вместо этого мы будем использовать механизм ```ModelForm```, который автоматически сгенерирует форму, основываясь на модели.**

**И в место всех строчек которые мы удалили пропишим вложенный класс ```Meta```**
```
class AddPostForm(forms.ModelForm):
    class Meta:
        model = Women
        fields = "__all__"
```
**Здесь мы определяем два атрибута в классе Meta:**

1. **```model``` — Этот атрибут указывает, с какой моделью должна быть связана форма. В данном случае мы указываем модель People, и форма автоматически будет работать с полями этой модели.**

2. **```fields``` — Этот атрибут указывает, какие поля модели должны быть отображены в форме. Если мы укажем ```fields = "__all__"```, это значит, что в форме будут отображены все поля модели, кроме тех, которые заполняются автоматически (например, поле ```id`` или ```created_at```).**

## Тестирование на сайте
**Теперь, после того как мы связали форму с моделью через ```ModelForm```, давайте проверим, как это работает на сайте. Переходим на страницу "Добавить статью", и мы увидим, что форма отобразилась, и все поля были автоматически сгенерированы. Эти поля были сгенерированы благодаря связи с моделью ```People```.**

## Явное указание полей
**Однако, на практике рекомендуется явным образом указывать список полей, которые нужно отобразить в форме. Это может быть полезно, если в модели есть поля, которые не должны отображаться в форме. В нашем случае, допустим, мы не хотим отображать поле для фотографии. Поэтому вместо ```fields = "__all__"``` мы укажем конкретный список полей, который нам нужно отобразить:**
```
fields = ["title", "slug", "content", "is_published", "cat"]
```
**После этого мы сохраняем изменения, переходим в форму и обновляем страницу. Действительно, поле для фотографии исчезло, как и было задумано.**

****
**Чтобы оформить поля "Заголовок" и "Текст статьи", применяем стили через атрибут ```widgets``` в дочернем классе формы. Для этого в классе ```Meta``` указываем словарь с настройками для каждого поля. Например:**
```
fields = ["title", "slug", "content", "is_published", "cat"]

widgets = {
    "title": forms.TextInput(attrs={'class': 'form-input', 'style': 'width: 400px;'}),
    "content": forms.Textarea(attrs={'cols': 60, 'rows': 10, 'style': 'width: 400px;'}),
    "slug": forms.TextInput(attrs={'class': 'form_input', 'style': 'width: 400px;'}),
}
```
*Объяснение*

1. **Поле ```title```:**

    * **Мы указываем, что оно должно использовать ```TextInput```.**
    * **Добавляем CSS-класс ```'form-input'```, чтобы стиль применился в HTML.
2. **Поле ```content```:**

   * **Определяем его как ```Textarea```.**
   * **Указываем параметры:**
        * **```cols```: 60 колонок ширины.**
        * **```rows```: 10 строк высоты.**
* **```attrs={'class': 'form-input', 'style': 'width: 400px;'}```: Здесь атрибут ```style``` задаёт ширину поля.**
* ***Для ```Textarea```, помимо ```cols``` и ```rows```, можно также задать ширину с помощью CSS: ```style='width: 600px;'```.**
***


### ***Если хотим увеличить длину ввода для текстового поля только через HTML (не меняя ```forms.py```), можно добавить атрибут ```style``` прямо в шаблоне:***
```
<form action="{% url 'add_page' %}" method="post">
    {% csrf_token %}
    
    <div class="form-error">{{ form.non_field_errors }}</div>

    {% for f in form %}
    <div style="margin-bottom: 10px;">
        <label class="form-label" for="{{ f.id_for_label }}" style="display: block;">{{ f.label }}: </label>
        {{ f.as_widget(attrs={'style': 'width: 500px;'}) }}
        <div class="form-error">{{ f.errors }}</div>
    </div>
    {% endfor %}
    
    <button type="submit" style="margin-top: 20px;">Добавить</button>
</form>
```



**После сохранения изменений, при обновлении формы в браузере, вы увидите, что размеры полей изменились, соответствуя указанным стилям.**
***
**Теперь добавим описание для поля выбора категории, чтобы вместо дефолтного значения (обычно это тире или пустое значение) отображалась строка "Категория не выбрана". Для этого добавим конструктор в класс формы:**
```
class AddPostForm(forms.ModelForm):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['cat'].empty_label = "Категория не выбрана"
```
*Объяснение*

### Конструктор формы:
* **Когда создается экземпляр ```AddPostForm```, автоматически вызывается его конструктор ```__init__```.**

* **Внутри конструктора вызываем родительский конструктор через ```super().__init__(*args, **kwargs)```. Это обязательно, чтобы базовый класс выполнил свои действия, например, подключение полей из модели.**
  
### Поле ```cat```:
* **После вызова базового конструктора создается локальное свойство ```fields```.**

* **У свойства ```fields``` есть ключ ```'cat'```, связанный с полем ```cat``` в модели.**
* **Устанавливаем для этого поля атрибут ```empty_label``` со значением "Категория не выбрана".**

***После сохранения изменений обновляем форму в браузере, и теперь в выпадающем списке вместо пустого значения отображается строка "Категория не выбрана".***
***

**Теперь займемся обработкой данных формы. Ранее в функции представления ```addpage()``` в файле ```views.py``` мы использовали следующий код для сохранения данных:**
```
People.objects.create(**form.cleaned_data)
```
**Однако для формы, связанной с моделью, есть более простой и удобный способ. Используем метод ```save()```:**
```
form.save()
```
*Объяснение* 

**Метод ```save```:**

* **Этот метод автоматически сохраняет данные формы в связанную таблицу базы данных.**
* **Так как форма ```AddPostForm``` связана с таблицей People, все данные из формы будут сохранены именно в эту таблицу.**

### Преимущество:

* **Нет необходимости вручную распаковывать словарь ```**form.cleaned_data``` и передавать данные методу ```create```.**
* **Метод ```save``` автоматически обрабатывает и проверяет данные, а в случае ошибки (например, уникальности URL) сгенерирует сообщение.**
***


### Удаление блока ```try-except```

1. **Удаляем блок ```try-except``` из функции представления ```addpage()```:**
```
try:
    form.save()
except:
    form.add_error(None, "Ошибка добавления поста")
```
### В целом наш код и его объяснение:
```
# Страница для добавления статьи
def addpage(request):
    # Если запрос был отправлен методом POST (пользователь отправил форму)
    if request.method == "POST":
        form = AddPostForm(request.POST) # Форма с заполненными данными
        if form.is_valid(): # Проверяем, валидны ли данные, введённые пользователем
            # Перенаправляем пользователя на главную страницу после успешного добавления
            form.save()
            return redirect("home")
    else:# Если пользователь просто открыл страницу
        form = AddPostForm() # Создаём пустую форму
    # Возвращаем шаблон `addpage.html`, передавая форму, меню и заголовок страницы
    return render(request, 'people/addpage.html', {
        'form': form, 
        'menu': menu, 
        'title': "Добавление статьи"
    })
```
### Ключевые моменты:
1. **Метод POST и GET:**

    * **Если запрос ```POST```, обрабатываем данные, отправленные пользователем.**
    * **Если запрос ```GET```, отображаем пустую форму.**
2. **Форма:**

    * **Форма создаётся на основе AddPostForm (связана с моделью People).**
    * **Проверка form.is_valid() проверяет, соответствуют ли данные всем требованиям формы и модели.**
3. **Ошибки формы:**
    * **Если форма невалидна (например, дублирующийся ```slug```), ошибки автоматически добавляются в объект формы. Они отображаются в шаблоне.**
4. **Перенаправление:**

* **После успешного сохранения данные отправляют пользователя на главную страницу (```home```).**

## *Проверка работы:*

1. **Переходим в браузер и обновляем страницу с формой.**
2. **Заполняем поля формы и нажимаем "Сохранить".**
3. **Если ввести неуникальный URL, появится сообщение об ошибке: *"Известные женщины с таким URL уже существуют."* Это сообщение генерируется автоматически и отображается на форме.**

**Таким образом, метод ```save``` значительно упрощает работу с данными. Django позволяет максимально автоматизировать процесс создания и обработки форм, включая валидацию и сохранение данных.**
***

## Добавление работы с изображениями
1. **Модификация формы в forms.py:**
    
    **Добавим функционал для работы с изображениями в форме, чтобы пользователь мог загружать изображение вместе с данными статьи. Все изменения сводятся к настройке формы, обработки данных во ```views``` и обновлению шаблона.**

    **Чтобы включить поле для загрузки изображения, добавим его в список ```fields```. Например:**
    ```
    fields = ["title", "slug", "content", "photo", "is_published", "cat"]
    ```
2. **Обработка файлов во ```views```:**
    
    **В функции представления ```addpage()``` добавим обработку файлов. Для этого передадим данные из коллекции ```request.FILES``` в форму:**
    ```
    form = AddPostForm(request.POST, request.FILES)
    ```
3. **Настройка шаблона ```addpage.html```:**
    **В HTML-шаблоне укажем дополнительный атрибут в теге ```<form>```. Полная строка будет выглядеть так:**
    ```
    <form action="{% url 'add_page' %}" method="post" enctype="multipart/form-data">
    ```
    **Атрибут ````enctype="multipart/form-data"``` обязателен при работе с файлами, иначе файлы не будут переданы на сервер.**
***
## Проверка работы
1. **Переходим в браузер, заполняем форму, включая загрузку изображения.**
2. **После нажатия на кнопку "Добавить":**
    * **Пост добавится в базу данных.**
    * **Загруженное изображение сохранится в папке ```media```, автоматически настроенной Django.**
***
## Преимущества автоматизации в Django
* **Django самостоятельно обрабатывает загрузку файлов, сохраняя их в указанной директории.**
* **Нет необходимости вручную писать код для сохранения файлов или их валидации — это уже встроено.**
* **Удобная работа с формами, связанными с моделями, позволяет минимизировать количество кода.**

## Создание пользовательского валидатора в Django

**Добавим пользовательский валидатор для проверки длины заголовка (```title```) в форме ```AddPostForm```. Если длина заголовка превышает 200 символов, форма отобразит сообщение об ошибке.**
***
### Механизм работы валидаторов
1. **Проверки валидности данных:**

    * **Стандартные валидаторы запускаются при вызове метода ```is_valid()```.**
    * **Если стандартные проверки проходят, запускаются пользовательские валидаторы, которые определяются с помощью метода ```clean_ + <имя_поля>```.**
2. **Последовательность проверки данных:**

    * **Стандартные валидаторы (из модели).**
    * **Пользовательские валидаторы (методы ```clean_<имя_поля>```).**
***

## Реализация пользовательского валидатора
**В файле ```forms.py```, внутри класса ```AddPostForm```, добавляем метод ```clean_title```:**
```
class AddPostForm(forms.ModelForm):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['cat'].empty_label = "Категория не выбрана"
    class Meta:
        model = People
        # fields = "__all__"
        fields = ["title", "slug", "content", "photo", "is_published", "cat"] # Перечисляем какие поля мы будем использовать
        widgets = {
            "title": forms.TextInput(attrs={'class': 'form-input', 'style': 'width: 400px;'}),
            "content": forms.Textarea(attrs={'cols': 60, 'rows': 10, 'style': 'width: 400px;'}),
            "slug": forms.TextInput(attrs={'class': 'form_input', 'style': 'width: 400px;'}),
        }
    
    def clean_title(self):
        title = self.cleaned_data['title'] # Получаем значение заголовка
        if len(title) > 200: # Проверяем длину заголовка
            raise ValidationError('Длина превышает 200 символов') # Генерируем ошибку валидации
        return title # Возвращаем значение, если оно корректное
```
***
### Как это работает
1. **Метод ```clean_title```:**

    * **Выполняется после проверки стандартных валидаторов модели.**
    * **Получает введенное пользователем значение ```title``` из коллекции ```cleaned_data```.**
    * **Если длина ```title``` превышает 200 символов, генерирует исключение ```ValidationError``` с сообщением об ошибке.**
    * **Если проверка проходит, метод возвращает значение ```title```.**
    
2. **Сообщение об ошибке:**

    * **Исключение ```ValidationError``` автоматически добавляется к списку ошибок формы и отображается рядом с полем ```title``` в шаблоне.**

***
### Проверка работы
1. **Зайти на страницу формы.**
2. **Ввести заголовок длиной более 200 символов.**
3. **Нажать "Добавить".**
4. **Увидеть сообщение об ошибке: "Длина превышает 200 символов".**

**Если длина заголовка меньше или равна 200 символам, форма успешно отправляется, данные сохраняются в базе данных.**

## Гибкость:

**Аналогичным образом можно написать валидатор для других полей (```slug```, ```content```, и т. д.). Можно проверять любые условия, например, уникальность, наличие запрещенных символов, использование шаблонов (регулярных выражений).**



















































