# Устранение дублирования с помощью пользовательских тегов в Django

**В Django часто возникает необходимость повторного использования одной и той же логики в разных местах. Один из примеров — это дублирование кода, связанного с выборкой данных из базы данных и их передачей в контекст шаблона. Примером такого дублирования является ситуации в файле ```views.py:```**

### Функция index (главная страница):
```
def index(request):
    posts = People.objects.all() 
    cats = Category.objects.all()  # Дублируемый код
    
    context = {
        'posts': posts,
        'cats': cats,  # Дублируемый код
        'menu': menu,
        'title': 'Главная страница',
        'cat_selected': 0,
    }
    return render(request, 'people/index.html', context=context)
```
### Функция show_category (отображение категорий):
```
def show_category(request, cat_id):
    posts = People.objects.filter(cat_id=cat_id) 
    cats = Category.objects.all()  # Дублируемый код
    
    if len(posts) == 0:
        raise Http404()
    
    context = {
        'posts': posts,
        'cats': cats,  # Дублируемый код
        'menu': menu,
        'title': 'Отображение по рубрикам',
        'cat_selected': cat_id,
    }
    return render(request, 'people/index.html', context=context)
```
**Здесь строки ```cats = Category.objects.all()``` и передача данных в контекст ```cats``` дублируются в обеих функциях, что нарушает принцип ```DRY (Don't Repeat Yourself — «не повторяйся»)```.**

## Решение: пользовательские теги
**Django предоставляет мощный инструмент для устранения таких дублирований — пользовательские теги. Они позволяют вынести повторяющийся код в отдельное место и использовать его повторно в шаблонах.**

***Пользовательские теги бывают двух типов:***

1. ***```Simple Tags``` (простые теги):***
   
    * **Подходят для выполнения простых операций и возврата значений, которые можно вставить в шаблон.**
    * **Не требуют сложной логики.**
2. ***```Inclusion Tags``` (включающие теги):***

    * **Используются для включения готового HTML-кода или сложных данных.**
    * **Они автоматически рендерят указанный шаблон и передают ему контекст.**

***Более подробная информация по*** [ссылке](https://ejudge.lksh.ru/lang_docs/djbook.ru/rel1.9/howto/custom-template-tags.html).***

## Создание и использование пользовательских тегов в Django
**Для устранения дублирования в коде можно использовать пользовательские теги. На примере мы рассмотрим, как создать простой тег, который будет загружать из базы данных рубрики и использоваться непосредственно в шаблоне.**
***
### Шаг 1: Подготовка каталога для пользовательских тегов
**Согласно документации Django, пользовательские теги должны находиться в специальном подкаталоге вашего приложения. В нашем случае приложение называется people.**

1. **В корне приложения создаем подкаталог templatetags. Нажимаем Enter, и папка готова.**

2. **Поскольку этот каталог должен быть пакетом, в нем необходимо разместить файл ```__init__.py```. Этот файл может быть пустым.**

3. **Внутри папки создаем Python-файл, где будет описана логика работы нового тега. Назовем файл ```people_tags.py```.**
   
### Шаг 2: Импорт модулей и моделей
**В начале файла ```people_tags.py``` импортируем модуль ```template``` и нашу модель ```Category``` из приложения ```people```:**
```
from django import template
from women.models import *
```
### Шаг 3: Создание экземпляра класса ```Library```
**Для регистрации собственных шаблонных тегов нужно создать экземпляр класса ```Library```.**
```
register = template.Library()
```
***Здесь мы обращаемся к модулю ```template```, создаем экземпляр класса ```Library```, и теперь переменная ```register``` будет ссылаться на этот экземпляр. Через нее мы будем регистрировать пользовательские теги.**
***
### Шаг 4: Описание функции для работы тега
**Теперь опишем функцию, которая будет выполнять необходимую задачу.**
```
def get_categories():
    return Category.objects.all()
```
* **Название функции: Мы придумали название ```get_categories```, так как тег будет возвращать все категории из базы данных.**

* **Тело функции: Здесь происходит обращение к модели ```Category``` и выборка всех записей ```Category.objects.all()```.Эта функция возвращает список всех категорий:**
*** 

### Шаг 5: Регистрация функции как тега
**Чтобы сделать эту функцию доступной в шаблоне, нужно зарегистрировать ее как тег. Для этого используем декоратор ```@register.simple_tag```:**
```
@register.simple_tag
def get_categories():
    return Category.objects.all()
```
### Вот так наша функция преобразуется в простой тег, который можно использовать в шаблонах нашего приложения. Рассмотрим пошагово:

1. ***Подключение пользовательских тегов в шаблоне***
   
    **Откройте файл ```base.html```. В начале файла подключаем наш модуль с пользовательскими тегами:**
    ```
    {% load women_tags %}
    ```
    **Это позволяет использовать теги, определенные в файле people_tags.py.**

2. ***Использование тега в шаблоне***

    **Имя тега соответствует имени функции, которая была зарегистрирована (```get_categories```). Теперь мы можем использовать его(```{% get_categories %}```) в шаблоне:**

    **Например, добавим вызов тега в базовый шаблон, где выводятся рубрики:**
    ```
    <!-- Sidebar слева -->
    <td valign="top" class="left-chapters">
    {% get_categories %}
    <ul id="leftchapters">
    ```
3. **Проверка работоспособности
    После обновления страницы появится список категорий из базы данных, например:**
    ```
    <QuerySet [<Category: Актрисы>, <Category: Певицы>]>
    ```
    **Этот вывод произошел благодаря тегу:**
    ```
    {% get_categories %}
    ```
    **Тег возвращает результат вызова функции ```Category.objects.all()```.**

4. ***Перебор списка категорий в шаблоне***
   
    **Чтобы отобразить категории на сайте, нужно перебрать их в цикле ```for```. Однако результат тега — это не переменная, а тег. Для работы с данными нужно сохранить их в переменную с помощью ключевого слова ```as```:**
    ```
    {% get_categories as categories %}
    ```
    **Теперь данные из тега сохранены в переменной ```categories```, и мы можем их обработать:**
    
    **Чуть ниже у нас есть такой цикл ```{% for c in cats %}```, мы эту ```cats``` переименуем в ```categories```**
    ```
    {% for c in categories %}
    <li>{{ c.name }}</li>
    {% endfor %}
    ```
5. **Очистка функций в ```views.py```
    После создания тега и его использования можно удалить из функций ```index``` и ```show_category``` строки, отвечающие за выборку категорий и передачу их в шаблон:**
    
        ```cats = Category.objects.all()```

        **А также убрать параметр ```'cats': cats``` из контекста.**
6. ***Переименование тега через параметр ```name```***

    **Если нужно, чтобы тег вызывался не по имени функции (```get_categories```), а по другому имени, это можно задать в декораторе ```@register.simple_tag``` с параметром ```name```:**
    ```
    @register.simple_tag(name="getcats")
    ```
    **После этого в шаблоне нужно заменить имя тега:**
    ```
    {% getcats as categories %}
    ```
    **Если не заменить имя, будет возникать ошибка, так как get_categories больше не доступен под старым именем.**

## Расмотрим второй тип пользовательских тегов - Включающие теги

**Включающие теги используются для генерации HTML-фрагментов, которые формируются на основе данных и возвращаются как часть шаблона. Это особенно полезно для вывода сложных структур HTML, например списков категорий. Давайте пошагово реализуем включающий тег для вывода списка категорий.**
***

### Шаг 1. Создаем включающий тег в ```people_tags.py```
**В файле ```people_tags.py``` добавим функцию включающего тега:**
    
* **```@register.inclusion_tag('women/list_categories.html')```: указывает, что результат функции будет рендериться с использованием шаблона ```list_categories.html```.**

* **Параметр cat_selected: позволяет выделять текущую категорию.**

* **Возвращаемый словарь: содержит данные, которые будут переданы в шаблон ```list_categories.html```.**

***
### Шаг 2. Создаем шаблон ```list_categories.html```

**В папке, где хранятся шаблоны приложения (например, ```women/templates/women```), создаем файл ```list_categories.html```.**

**Содержимое файла ```list_categories.html```:**
```
<ul id="leftchapters">
    {% if cat_selected == 0 %}
        <li class="selected">Все категории</li>
    {% else %}
        <li><a href="{% url 'home' %}">Все категории</a></li>
    {% endif %}

    {% for c in cats %}
        {% if c.pk == cat_selected %}
            <li class="selected">{{ c.name }}</li>
        {% else %}
            <li><a href="{{ c.get_absolute_url }}">{{ c.name }}</a></li>
        {% endif %}
    {% endfor %}
</ul>

```
* **Цикл по ```cats```: Формирует список категорий.**
* **```cat_selected```: Управляет выделением текущей категории (добавляет класс ```selected```).**
  
***
## Шаг 3. Изменяем шаблон ```base.html```
**Теперь подключаем и используем включающий тег в основном шаблоне ```base.html```.**

1. **Удаляем старый код, связанный с выводом категорий:**
```
{% for c in categories %}
    {% if c.pk == cat_selected %}
        <li class="selected">{{c.name}}</li>
    {% else %}
        <li><a href="{{ c.get_absolute_url }}">{{c.name}}</a></li>
    {% endif %}
{% endfor %}

```
1. **Убираем подключение простого тега ```{% getcats as categories %}```**

2. **Добавляем вызов включающего тега:**
```
{% show_categories %}
```
* **```cat_selected```: Передаем выбранную категорию**
***

**Включающий тег ```{% show_categories %}``` играет ключевую роль в отображении списка актрис и певиц на странице. Этот тег возвращает сгенерированный HTML-код, который формируется на основе шаблона ```list_categories.html```. Благодаря этому подходу можно удобно вставлять различные элементы интерфейса в разные части проекта, обеспечивая динамичное и гибкое отображение данных.**

**Это можно легко проверить. Удаляем строку в ```base.html```, а именно ```{% show_categories %}```. Перезапускаем нашу страницу и видим, что названия актрис и певиц исчезли.**

**Возвращаем строку ```{% show_categories %}``` обратно.**

**Отображение действительно происходит с помощью включающего тега.**

## Итог

**Использование включающих тегов, таких как ```{% show_categories %}```, позволяет:**

* **Разделять логику формирования данных и их отображение.**

* **Повышать читаемость и повторное использование кода.**

* **Управлять содержимым страницы более гибко.**

**Если потребуется изменить представление списка категорий, достаточно отредактировать шаблон ```list_categories.html```, а включающий тег автоматически подхватит изменения.**
***

## Дополнительная проблема с работой списка

**На данном этапе список категорий работает не полностью корректно: при выборе, например, пункта "Актрисы", соответствующий пункт не выделяется. Мы устраним эту проблему позже, когда разберем, как передавать параметры включающим тегам.**
***

### Работа с параметрами в простых тегах
**Для начала вернемся в проект и откроем файл ```people_teg.py```, где определяются теги. Рассмотрим, как можно передавать параметры простым тегам на примере функции ```get_categories```.**

***Пропишем следующую реализацию:***
```
@register.simple_tag(name="getcats")
def get_categories(filter=None):
    if not filter:
        return Category.objects.all()
    else:
        return Category.objects.filter(pk=filter)
```
### Объяснение работы кода:

* **Если параметр ```filter``` равен ```None```, выбираются все категории через метод ```all()```.**
  
* **Если же ```filter``` принимает какое-либо значение, используется метод ```filter``` ```(pk=filter)```, который фильтрует категории по указанному значению первичного ключа ```pk```.**
***

## Тестирование простого тега в шаблоне
**Теперь проверим, как передавать параметр ```filter``` в наш простой тег ```getcats``` из шаблона ```base.html```.**

1. ***Без параметров:***
  
    **Сначала добавим в шаблон вызов тега без параметров, чтобы убедиться, что он работает:**
    ```
    <!-- Sidebar слева -->
    <td valign="top" class="left-chapters">
    {% getcats %}
    </td>
    ```
    **После обновления страницы вы увидите, что список категорий возвращается как объект QuerySet: ```<QuerySet [<Category: Актрисы>, <Category: Певицы>]>```**

2. ***С параметром ```filter```:***
    
    **Теперь передадим тегу параметр ```filter```, присвоив ему значение ```1```, чтобы отобразить только одну категорию (с ```pk=1```):**
    ```
    {% getcats filter=1 %}
    ```
    **После обновления страницы отобразится: ```<QuerySet [<Category: Актрисы>]>```**
3. ***Без имени параметра:***
    
    **Вместо указания имени параметра ```filter``` можно просто передать значение. Это будет интерпретироваться как первый параметр:**
    ```
    {% getcats 2 %}
    ```
    **Результат: ```<QuerySet [<Category: Певицы>]>```**

## Параметры для включающего тега
**Теперь реализуем аналогичный механизм для включающего тега. Добавим в функцию ```show_categories``` два параметра:**

* **```sort```: Определяет порядок сортировки категорий.**
* **```cat_selected```: Указывает, какая категория выбрана.**

***Код функции:***
```
@register.inclusion_tag('list_categories.html')
def show_categories(sort=None, cat_selected=0):
    if not sort:
        cats = Category.objects.all()
    else:
        cats = Category.objects.order_by(sort)
    return {"cats": cats, "cat_selected": cat_selected}
```
### Объяснение работы:

* **Если sort не задан, выбираются все категории через метод ```all()```.**

* **Если ```sort``` задан, происходит сортировка по указанному полю.**

* **Второй параметр ```cat_selected``` передается в шаблон ```list_categories.html```, чтобы можно было определить, какая рубрика выбрана, и выделить ее, например, с помощью класса ```selected```.**
***

### Использование включающего тега в шаблоне
**В шаблоне ```base.html``` заменим вызов простого тега ```{% getcats %}``` на вызов включающего тега с параметрами.**

**Пример использования:**
```
{% show_categories '-name' cat_selected %}
```
### Объяснение параметров:

* **```'-name'``` — выполняется сортировка по полю ```name``` в обратном порядке.**

* **```cat_selected``` — переменная, определенная в шаблоне, которая передается тегу для выделения выбранной категории.**

**Если удалить знак минуса из -name, порядок сортировки изменится:**
```
{% show_categories 'name' cat_selected %}
```
## Итог

**Теперь наш включающий тег стал более функциональным. Он не только отображает категории, но и позволяет:**

1. **Выполнять сортировку категорий.**

2. **Определять и выделять выбранную категорию в интерфейсе.**

**Обновленная функциональность тега ```{% show_categories %}``` делает проект более гибким и наглядным.**


***



# Доп задание.
## Так же дополнительно пропишем menu зи views.py

**Чтобы использовать переменную ```menu``` из ```views.py``` в нашем пользовательском теге в ```people_tags.py```, есть несколько подходов. Поскольку мы хотите интегрировать это через ```@register.inclusion_tag```, мы пошагово сделаем это.**

1. ### Создание шаблона ```list_menu.html``` в папке ```templates/people```
    ***Шаблон ```list_menu.html``` будет использоваться для отображения меню. Мы будем передавать данные о меню через пользовательский тег и отображать их с помощью цикла.**

    **Шаги:**

    * **В папке ```templates/people``` создайте файл ```list_menu.html```.**
    * **В этом файле создайте структуру HTML для меню. Важно убрать маркеры списка с помощью CSS, чтобы меню отображалось без них.**
    ```
        <!-- Верхнее меню -->
    <ul class="menu-list">
        {% for item in menu %}
            <li><a href="{% url item.url_name %}">{{ item.title }}</a></li> <!-- Вставка элементов меню -->
        {% endfor %}
    </ul>

    <!-- Стили для меню (убираем маркеры) -->
    <style>
        .menu-list {
            list-style-type: none;  <!-- Убираем маркеры -->
            padding: 0;
            margin: 0;
        }

        .menu-list li {
            margin-bottom: 10px; <!-- Отступы между элементами меню -->
        }
    </style>

    ```

2. ### Создание пользовательского тега в people_tags.py
    **Теперь создадим пользовательский тег, который будет передавать меню в шаблон через декоратор @register.inclusion_tag. Это позволит нам не прописывать меню вручную в каждом шаблоне, а просто вставлять вызов тега.**

    **Шаги:**

    * **В файле people_tags.py (или создайте его, если его нет) добавьте следующее:**
    ```
    @register.inclusion_tag("people/list_menu.html")
    def show_menu():
        return {
            "menu": menu,
        }
    ```
    **Здесь мы создаем функцию ```show_menu()```, которая будет передавать переменную ```menu``` в шаблон ```list_menu.html```. Этот тег теперь можно использовать в любом шаблоне, где требуется меню.**

3. ### Использование пользовательского тега в шаблоне ```base.html```
    **После создания тега, можно удалить старую логику с циклом по элементам меню и использовать новый тег для отображения меню.**

    **Шаги:**

    * **В файле ```base.html``` нужно загрузить теги, используя ```{% load people_tags %}```.**
    * **Замените старый цикл на вызов нашего пользовательского тега ```{% show_menu %}```, который будет рендерить меню.**
    ```
    {% load people_tags %}  <!-- Загрузка пользовательских тегов -->

    <!-- Блок главного меню -->
    {% block mainmenu %}
        <div class="header">
            <ul id="mainmenu" class="mainmenu">
                <!-- Логотип -->
                <li class="logo"><a href="{% url "home" %}"><div class="logo"></div></a></li>
            
                <!-- Вставка пользовательского тега для отображения меню -->
                {% show_menu %}
            </ul>
            <div class="clear"></div>
        </div>
    {% endblock %}
    ```
    **Теперь меню будет отображаться через пользовательский тег, который мы создали ранее. Важно, что код для цикличного перебора элементов меню удален, и меню передается через тег.**

4. ### Удаление передачи меню из представлений
    **Теперь, когда меню передается через пользовательский тег, нет необходимости передавать его в контексте представлений. Мы удалим строки, где меню передавалось в контексте.**

    **Шаги:**

    * **В функциях представлений (например, в ```index``` или ```show_category```) уберите строки, которые передают ```menu`` в контекст:**
    ```
    def show_category(request, cat_id):
        posts = People.objects.filter(cat_id=cat_id) 

    
        if len(posts) == 0:
            raise Http404
    
        context = {
            'posts': posts,
            'title': 'Отображение по рубрикам',
            'menu': menu,                              <------ удалить
            'cat_selected': cat_id,
        }
        return render(request, 'people/index.html', context=context)
    ```







