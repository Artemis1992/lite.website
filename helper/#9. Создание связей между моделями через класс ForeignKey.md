## Теперь мы добавим еще одну таблицу для категорий и свяжем ее с таблицей постов. Таким образом, каждая статья будет соотнесена с определенной категорией.

*Например:*

* ***Женщины спортсменки***
* ***Женщины актрисы***
* ***Женщины певицы***

**Таблица People будет связана с таблицей категорий. Это означает, что если в будущем потребуется переименовать какой-либо раздел, достаточно будет изменить название только в одном месте (в таблице категорий). Это изменение не затронет тысячи записей из таблицы постов People.**

**Такой подход имеет множество преимуществ. Разделение данных на несколько таблиц и установление связей между ними называется нормализацией данных. Следование этому принципу позволяет избежать сложностей при работе с базами данных.**

***

## Задача

**В проекте нужно определить еще одну модель для категорий и связать ее с таблицей постов. Для этого в таблицу постов добавим поле ```cat_id```, которое будет определено как внешний ключ (```Foreign Key```) и будет хранить идентификатор категории.**

*В таблице категорий создадим два поля:*

* ***```id``` — уникальный идентификатор категории***
* ***```name``` — название категории***

*Эту связку реализуем с использованием ORM Django.*
***
## Связи в Django
*Django предоставляет три специальных класса для создания связей между моделями:*

1. **```ForeignKey```
Используется для связи "многие к одному". В нашем случае эта связь подходит, так как множество постов будет связано с одной категорией. Мы будем использовать именно этот класс.**

2. **```ManyToManyField```
Используется для связи "многие ко многим". Подходит, например, для реализации тегов.**

3. **```OneToOneField```
Используется для связи "один к одному". Применяется довольно редко.**

***
## ForeignKey: основные параметры

**Чтобы воспользоваться классом ForeignKey, нужно указать два обязательных аргумента:**
```
ForeignKey(<Ссылка на первичную модель>, on_delete=<ограничение при удалении>)
```

* ***Первичная модель — это модель категории:***
  ```
    class Category(models.Model):
        name = models.CharField(max_length=255)
  ```
* ***Вторичная модель — это модель постов ```People```:***
    ```
    class People(models.Model):
        title = models.CharField(max_length=255)
        content = models.TextField()
        photo = models.ImageField(upload_to='photos/')
        time_create = models.DateTimeField(auto_now_add=True)
        time_update = models.DateTimeField(auto_now=True)
        is_published = models.BooleanField(default=True)
        cat = models.ForeignKey(Category, on_delete=models.PROTECT)
    ```
**Поэтому в качестве первого аргумента мы должны указать ссылку на первичную модель. А второй параметр ```on_delete``` определяет ограничение при удалении записи первичной модели. Дело в том, что ключ ```cat``` должен ссылаться на какую-то рубрику. Если рубрика по каким-то причинам удаляется, то нам нужно решить, что делать с записями, которые ссылаются на эту рубрику. Существует несколько вариантов:**

1. **```models.CASCADE```**

    **При удалении записи из первичной модели (в нашем случае таблица ```Category```) удаляются все   записи из вторичной модели (```People```), связанные с удаленной категорией.**

2. **```models.PROTECT```**
    
    **Удаление записи из первичной модели запрещается, если она используется во вторичной модели. При попытке удаления выбрасывается исключение.**

3. **```models.SET_NULL```**
    
    **При удалении записи первичной модели значение ```ForeignKey``` во вторичной модели устанавливается в ```NULL```. Для этого поле должно иметь атрибут ```null=True```.**

4. **```models.SET_DEFAULT```**
   
    **То же самое, что и ```SET_NULL```, но вместо ```NULL``` устанавливается значение по умолчанию, которое должно быть определено через атрибут ```default``` в поле ```ForeignKey```.**

5. **```models.SET(<значение>)```**
    
    **Позволяет установить пользовательское значение для записи при удалении записи из первичной модели**

6. **```models.DO_NOTHING```**

    **Удаление записи в первичной модели никак не влияет на записи во вторичной модели.**

***Пример использования:***

```ForeignKey(<Ссылка на первичную модель>, on_delete=<ограничение при удалении>)```

**Установим ограничения с помощью ```models.CASCADE```. Если это поведение нам не подходит, можно использовать другой вариант.**

***

## Пример использования ```ForeignKey``` для связи (многие к одному)
**Для этого откроем проект, файл ```models.py``` в приложении ```People```, и пропишем еще одну модель, которая будет называться ```Category```:**
```
class Category(models.Model):
    name = models.CharField(max_length=100, db_index=True)  # Название категории

    def __str__(self):
        return self.name  # Для отображения названия категории в админке
```
**Теперь добавим внешний ключ в модель ```People```:**

```
class People(models.Model):
    title = models.CharField(max_length=255)  # Заголовок или имя (макс. 255 символов)
    content = models.TextField(blank=True)  # Текстовое поле, может быть пустым
    photo = models.ImageField(upload_to="photos/%Y/%m/%d/")  # Путь для загрузки фото
    time_create = models.DateTimeField(auto_now_add=True)  # Время создания записи
    time_update = models.DateTimeField(auto_now=True)  # Время обновления записи
    is_published = models.BooleanField(default=True)  # Статус публикации (по умолчанию — опубликовано)
    cat = models.ForeignKey('Category', on_delete=models.PROTECT)  # Связь с таблицей категорий


    def __str__(self):
        return self.title
```
## Объяснение реализации
1. **Автоматический суффикс ```_id```**
   
    **Django автоматически добавляет суффикс ```_id``` к полям, связанным через ```ForeignKey```. В базе данных поле будет называться ```cat_id```, хотя в модели оно указано как ```cat```.**

2. **Аргумент ```on_delete=models.PROTECT```**

    **В этом случае мы запрещаем удаление категорий, которые используются в модели ```People```. При попытке удаления выбрасывается исключение.**

## Добавление внешнего ключа: модификация существующих таблиц и создание связанных моделей
```
cat = models.ForeignKey('Category', on_delete=models.PROTECT)
```
**В этой строке может возникнуть вопрос: почему мы передаем ссылку на модель ```'Category'``` в виде строки? На самом деле ссылку ```Category``` можно передавать и без заключения в кавычки, т.е. непосредственно указывать класс категории без кавычек.**

**Но так как класс ```Category``` идет после модели ```people```, то возникает ошибка: Неопределен класс ```Category```. Мы могли бы записать класс ```Category``` выше, перед моделью ```People```, и тогда никаких проблем бы не возникло. Но если класс записан позже, необходимо указать его как строку ```'Category'```**

**Можно делать и так, и иначе, в зависимости от того, как нам удобнее.**

****
**Формально модели у нас определены, и пришло время создать соответствующие таблицы в базе данных. Фактически первую таблицу ```People``` нам нужно лишь модифицировать, добавив поле**
```
cat = models.ForeignKey('Category', on_delete=models.PROTECT)
```
**как внешний ключ. А вторую таблицу, связанную с моделью ```Category```, нужно создать целиком. Для этого необходимо создать новую миграцию.**

***Переходим в терминал и вводим команду:***
```
>>> python manage.py makemigrations

(venv) PS D:\My Dream\virtual environment\coolsite> python manage.py makemigrations
System check identified some issues:

WARNINGS:
?: (staticfiles.W004) The directory 'D:\My Dream\virtual environment\coolsite\static' in the STATICFILES_DIRS setting does not exist.
It is impossible to add a non-nullable field 'cat' to people without specifying a default. This is because the database needs something to populate existing rows.
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
 2) Quit and manually define a default value in models.py.
Select an option:
```
**По идее, должна пойти создание миграции, но полноценная миграция не может быть выполнена. Этот пример был специально приведен для того, чтобы мы понимали лучше процесс перестройки структуры таблиц в базе данных. Что же тут не так?**

**Итак, в нашей таблице ```People``` уже есть записи...**
```
class People(models.Model):
    title = models.CharField(max_length=255)
    content = models.TextField(blank=True)
    photo = models.ImageField(upload_to="photos/%Y/%m/%d/")
    time_create = models.DateTimeField(auto_now_add=True)
    time_update = models.DateTimeField(auto_now=True)
    is_published = models.BooleanField(default=True)
    cat = models.ForeignKey('Category', on_delete=models.PROTECT)
```
***И мы добавляем еще одно поле ```cat```. Но это поле ```cat``` должно ссылаться на запись из первичной модели ```Category```.***
```
class Category(models.Model):
    name = models.CharField(max_length=100, db_index=True)  # Всего 100 символов, и поиск будет происходить с помощью индекса, а это значит чуть быстрее.
    
    def __str__(self):  # Дандер метод, который возвращает имя категории.
        return self.name
```
**А в категории у нас нет никаких записей, у нас даже таблицы такой нету. Отсюда возникает такой вопрос у фреймворка: что ему делать?**

**Давайте временно сделаем следующим образом: мы нажмем -2- и выйдем из процесса...**

**Теперь в поле ```cat``` мы укажем временно необязательным, прописываем значение ```null=True```**
```
cat = models.ForeignKey('Category', on_delete=models.PROTECT, null=True)
```
**Мы тут указываем, что можно заполнять его нулями. Снова перейдем в терминал и выполним ```makemigrations```:**

```
>>> python manage.py makemigrations

(venv) PS D:\My Dream\virtual environment\coolsite> python manage.py makemigrations
System check identified some issues:

WARNINGS:
?: (staticfiles.W004) The directory 'D:\My Dream\virtual environment\coolsite\static' in the STATICFILES_DIRS setting does not exist.
Migrations for 'people':
  people\migrations\0002_category_people_cat.py
    + Create model Category
    + Add field cat to people
(venv) PS D:\My Dream\virtual environment\coolsite> 
```
**Теперь миграция прошла успешно, и у нас появился новый файл миграции ```0002_category_people_cat.py``` в проекте ```people```.**

**Этот файл модифицирует файл ```0001_initial.py```, и если мы заглянем в файл ```0002```, то увидим, что он формирует таблицу с именем ```Category```, а также добавляет два поля в таблицу ```People```.**

**Теперь давайте выполним эти миграции:**
```
>>> python manage.py migrate

System check identified some issues:

WARNINGS:
?: (staticfiles.W004) The directory 'D:\My Dream\virtual environment\coolsite\static' in the STATICFILES_DIRS setting does not exist.
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, people, sessions
Running migrations:
  Applying people.0002_category_people_cat... OK
```
**Давайте убедимся, что все прошло правильно. Открываем программу ```SQLiteStudio```. Теперь у нас есть две таблицы: ```people_people``` и ```people_category```. Если откроем таблицу ```people_category```, то увидим два поля: ```id``` и ```name```, но данных в этой таблице нет. В таблице ```people_people``` появилось еще одно поле ```cat_id```. Значения в этом поле будут равны NULL, так как мы разрешили этому полю принимать значение NULL.**

## "Изменение структуры базы данных: работа с категориями и обновление данных"

**Вообще, такие операции по внесению изменений в структуры ранее созданных баз данных — это крайний шаг. Рекомендуется на самом начале проектирования сайта тщательно продумать организацию данных и связей, а затем уже работать с уже имеющимися таблицами, не внося существенных изменений в их структуру. То, что мы сделали сейчас, — это учебный пример, как в принципе можно делать, но лучше этого избегать.**

**Все таблицы у нас сформированы, и давайте теперь добавим две категории в новую таблицу ```category```. Для этого перейдем в терминал и выполним команду:**

```
>>> python manage.py shell
```
**Входим в оболочку Django. Импортируем модели:**
```
from people.models import *
```
**Теперь используем модель ```Category```:**
```
Category.objects.create(name='Актрисы')

```
**Создадим еще одну рубрику:**
```
Category.objects.create(name='Певицы')
```
**Теперь переходим в базу данных, обновляем таблицу ```Category``` и видим, что у нас добавились две рубрики.**

**Затем в таблице ```people``` у поля ```cat_id``` проставим везде единицу. То есть, мы сделаем так, что все записи будут соответствовать актрисам. Переходим в терминал и выполняем команду:**
```
w_list = People.objects.all()
```
**Эта команда получит список всех записей таблицы ```people```. Далее, с помощью метода ```update```, изменим поле ```cat_id``` на значение ```1```:**
```
w_list.update(cat_id=1)
```
**Переходим в таблицу ```people```, обновляем и видим, что все значения NULL поменялись на ```1```.**

## Модели Django: динамическое создание экземпляров и связь с базовым классом ```models.Model```

**Когда мы определяем модель ```People```, ее атрибуты являются ссылками на экземпляры классов полей. Например:**

* ***Атрибут ```title``` — это ссылка на экземпляр класса ```CharField```.***
* ***Атрибут ```content``` — на экземпляр класса ```TextField```.***
* ***И так далее.***

### Модель People
```
>>> People.title
<django.db.models.query_utils.DeferredAttribute object at 0x000002993AD0CB90>
```
**Мы видим, что это ссылка на объект, а не на строку. Это важный момент.**
## Атрибуты модели
**Атрибуты, которые определяем в классе People, задают набор и тип полей таблицы базы данных, но не содержат конкретных данных записей:**
```
class People(models.Model):
    title = models.CharField(max_length=2000)
    content = models.TextField(blank=True)
    photo = models.ImageField(upload_to='photos/%Y/%m/%d/')
    time_create = models.DateTimeField(auto_now_add=True)
    time_update = models.DateTimeField(auto_now=True)
    is_published = models.BooleanField(default=True)
    cat = models.ForeignKey('Category', on_delete=models.PROTECT)
```
**Данные появляются только при создании экземпляров класса. Например:**
```
w1 = People(title='None1', content='None2', cat_id=1)
```
***В этот момент:***
* **Свойство ```title``` становится строкой ```'None1'```.**
* **Свойство ```content``` содержит строку ```'None2'```.**
* **Свойство ```cat``` ссылается на экземпляр модели ```Category```.**

### Как это работает

**Метаморфозы происходят благодаря конструктору базового класса ```models.Model```. Если конструктор класса ```People``` отсутствует, вызывается родительский, который:**

* **Создает локальные свойства (```title```, ```content```, ```photo``` и т. д.).**
* **Преобразует их в типы, указанные в модели.**

**Проверим в консоли:**
```
>>> p1 = People(title='t1', content='c1', cat_id=1)
>>> type(w1.title)
<class 'str'>
```
**Значение ```p1.title``` теперь является строкой ```'t1'```, а ```type(p1.cat)``` покажет:**
```
>>> type(p1.cat)
<class 'people.models.Category'>
```
**Кроме того, экземпляры моделей получают свойство ```pk``` (Primary Key). До сохранения в базу данных его значение равно ```None```:**
```
>>> p1.pk
<People: None1>
```
**Другие поля также остаются неопределенными:**
```
>>> print(p1.id, p1.time_create, p1.time_update) 
None None None
```
### SQL-запросы
**Создание экземпляра модели ```p1``` не добавляет запись в базу данных. Однако обращение к внешнему ключу, например:**
```
>>> type(p1.cat) 
<class 'people.models.Category'>
```
## Как Django обрабатывает SQL-запросы для моделей
**Если мы посмотрим на SQL-запросы, которые были выполнены, например:**
```
>>> from django.db import connection
>>> connection.queries

[{'sql': 'SELECT "people_category"."id", "people_category"."name" FROM "people_category" WHERE "people_category"."id" = 1 LIMIT 21', 'time': '0.016'}]
```
**То мы заметим, что выполнен SQL-запрос, обращающийся к таблице ```Category```. Этот запрос был выполнен не в момент обращения к полю ```title```, а при попытке получить значение внешнего ключа ```cat``` в модели ```People```.**

### Пояснение поведения Django
1. **Локальные свойства экземпляра**

**Поле ```title``` и остальные текстовые или числовые свойства экземпляра модели ```People``` (например, ```content```, ```is_published```) инициализируются непосредственно в момент создания объекта:**
```
p1 = People(title='Example', content='Sample content', cat_id=1)
<People: Example>
```
**Поэтому обращение к ```p1.title``` просто возвращает строку ```Example``` без выполнения SQL-запросов.**

1. **Внешний ключ ```cat```**

    **Поле ```cat``` связано с моделью ```Category``` через внешний ключ (```ForeignKey```). Однако при создании экземпляра ```People``` Django не загружает данные из связанной таблицы. Вместо этого, если вы обращаетесь к свойству ```p1.cat```, Django проверяет, были ли данные загружены. Если нет, он выполняет SQL-запрос к базе данных, чтобы получить данные из таблицы ```Category```.**

### Объяснение работы с Django и SQL-запросами

**Выход из Django Shell и повторный вход:**
```
>>> exit()
(venv) PS D:\virtual environment\Python\Django\itvo\coolsite> python manage.py shell
```
**Создаем экземпляр класса People:**
```
>>> from people.models import *
>>> p1 = Women(title='t1', content='c1', cat_id=1)
```
**Если мы проверим список SQL-запросов:**
```
>>> from django.db import connection
>>> connection.queries
[]
```
**Список будет пуст, так как мы пока не обращались к связанным данным. Однако, если мы вызовем поле ```cat```:**
```
>>> p1.cat
<Category: Актрисы>
```
**Мы видим название рубрики — Актрисы.**

***Почему это произошло?***

**Django автоматически выполнил SQL-запрос, чтобы получить данные из таблицы ```Category```, поскольку поле ```cat``` ссылается на внешний ключ. Мы указали ```cat_id=1```, а это означает связь с первой рубрикой в таблице ```Category```. Как только Django понадобились данные, которых не было в памяти, он автоматически обратился к базе данных.**

```
>>> connection.queries

[{'sql': 'SELECT "people_category"."id", "people_category"."name" FROM "people_category" WHERE "people_category"."id" = 1 LIMIT 21', 'time': '0.000'}]
```

**Получение записи с ```pk=2```:**

**Обратимся к базе данных и выберем вторую запись (```pk=2```):**
```
>>> p2 = People.objects.get(pk=2)
```
**Если снова посмотрим список запросов:**
```
[{'sql': 'SELECT "people_category"."id", "people_category"."name" FROM "people_category" WHERE "people_category"."id" = 1 LIMIT 21', 'time': '0.000'}, {'sql': 'SELECT "people_people"."id", "people_people"."title", "people_people"."content", "people_people"."photo", "people_people"."time_create", "people_people"."time_update", "people_people"."is_published", "people_people"."cat_id" FROM "people_people" WHERE "people_people"."id" = 2 LIMIT 21', 'time': '0.047'}]
```
**Теперь видим, что в коллекции запросов уже два SQL-запроса:**

1. **Первый запрос для получения категории.**

2. **Второй — для получения данных из таблицы People.**

***
***Работа с данными из записи:***
**Посмотрим заголовок записи:**
```
>>> p2.title
'Марго Робби'
```
**Теперь выведем рубрику для этой записи:**
```
>>> p2.cat
<Category: Актрисы>
```
**Django выполнил еще один SQL-запрос для получения названия категории:**

***Подтверждение в ```queries```:***

**Если снова проверим список запросов:**
```
>>> connection.queries
[
{
    'sql': 'SELECT "people_category"."id", "people_category"."name" FROM "people_category" WHERE "people_category"."id" = 1 LIMIT 21', 
    'time': '0.000'
},
{
    'sql': 'SELECT "people_people"."id", "people_people"."title", "people_people"."content", "people_people"."photo", "people_people"."time_create", "people_people"."time_update", "people_people"."is_published", "people_people"."cat_id" FROM "people_people" WHERE "people_people"."id" = 2 LIMIT 21', 
    'time': '0.016'
},
{
    'sql': 'SELECT "people_category"."id", "people_category"."name" FROM "people_category" WHERE "people_category"."id" = 1 LIMIT 21', 
    'time': '0.000'
}
]

```
**Третий запрос появился, потому что мы обратились к ```w2.cat```. Django автоматически загрузил связанные данные.**

***
***Обращение к конкретным атрибутам:***

**Поле ```cat``` в модели ```People``` ссылается на экземпляр класса ```Category```. У модели ```Category``` есть атрибут ```name```, который можно вывести так:**
```
>>> w2.cat.name
'Актрисы'
```
**Таким образом, Django предоставляет удобный доступ к связанным данным, выполняя SQL-запросы только по мере необходимости. Это позволяет эффективно управлять запросами и загружать только те данные, которые нужны.**

## Отображение категорий и фильтрация записей по рубрикам в Django

**Мы создали таблицу ```Category``` и установили связь с таблицей ```People```. Далее мы реализовали отображение списка категорий в базовом шаблоне ```base.html``` вместо статического списка:**
```
<li class="selected">Все категории</li>
<li><a href="#">Актрисы</a></li>
<li><a href="#">Певицы</a></li>
<li><a href="#">Спортсменки</a></li>
```
**Запишим следующий. Для этого в шаблоне был добавлен следующий код:**
```
{% if cat_selected == 0 %}
    <li class="selected">Все категории</li>
{% else %}
    <li><a href="{% url 'home' %}">Все категории</a></li>
{% endif %}

{% for c in cats %}
    {% if c.pk == cat_selected %}
        <li class="selected">{{c.name}}</li>
    {% else %}
        <li><a href="{{ c.get_absolute_url }}">{{c.name}}</a></li>
    {% endif %}
{% endfor %}
```
**В нашем шаблоне будет отображаться такая ссылка:**
```
<li class="selected">Все категории</li>
```
**Она будет отображаться всегда. Если ```cat_selected == 0```, то мы отображаем её не как ссылку, а просто как текст. Если же ```{% if cat_selected != 0 %}```, то мы её отображаем как ссылку:**
```
<li><a href="{% url 'home' %}">Все категории</a></li>
```
**Все последующие рубрики формируем с помощью цикла. Мы передаём коллекцию ```cats```, перебираем её. Эта коллекция будет состоять из объектов класса категорий. В самом цикле проверяем: если первичный ключ ```pk``` равен ```cat_selected```, то текущую рубрику выводим не как ссылку, а просто как текст, и эта рубрика будет выбранной.**

***Иначе она будет отображаться как ссылка:***
```
<li><a href="{{ c.get_absolute_url }}">{{ c.name }}</a></li>
```
**Мы отображаем её по имени ```{{ c.name }}```, а ссылку формируем с помощью метода ```get_absolute_url```. Чтобы воспользоваться данным методом, нам нужно его прописать в ```models.py```.**

***Мы копируем...***

```
def get_absolute_url(self):
        return reverse('category', kwargs={"cat_id": self.pk})
```

**В классе модели ```Category``` мы прописываем метод ```get_absolute_url```. Имя маршрута меняем с ```'post'``` на ```'category'```. Для этого параметром маршрута будет ```cat_id```, а значение параметра передаём через идентификатор текущей записи — ```self.pk```.**

**Далее в файле ```urls.py``` создаём маршрут с именем ```'category'```. Этот маршрут будет принимать параметр ```cat_id```, который указывает на идентификатор конкретной категории. Он позволит генерировать ссылки для категорий с помощью метода ```get_absolute_url```.**
```
path('category/<int:cat_id>/', show_category, name='category'),
```
**Он у нас будет иметь шаблон ```'category/<int:cat_id>/'```, а реагировать на этот маршрут будет функция ```show_category```. Название маршрута будет ```'category'```.**

**Теперь остаётся прописать функцию ```show_category```. Она будет находиться в файле ```views.py``` и выглядеть следующим образом:**
```
def show_category(request, cat_id):
    return HttpResponse(f"Отображение категорий с id = {cat_id}")
```
**Эта функция будет служить заглушкой. У неё будет параметр ```cat_id```, и значение ```{cat_id}``` будет отображаться на странице.**

**И последнее: чтобы шаблон ```base.html``` заработал, ему нужно передать коллекцию ```cats``` и переменную ```cat_selected```.**

**Для этого переходим в ```views.py```, где у нас уже есть функция ```def index()```. В этой функции мы дополнительно считываем записи из таблицы ```Category``` и передаём их в шаблон как коллекцию ```cats```.**

**В функции ```index``` мы сначала получаем записи из таблицы ```Category```:**
```
cats = Category.objects.all()
```
**Добавляем эти данные в ```context```:**
```
context = {
    'posts': posts,        # Список записей
    'cats': cats,          # Коллекция категорий
    'menu': menu,          # Меню
    'title': 'Главная страница',  # Заголовок страницы
    'cat_selected': 0,     # Выбранная категория (0 — все категории)
}
```
**Список категорий, полученный в ```cats```, передаётся в шаблон ```people/index.html```, который расширяет базовый шаблон ```base.html```.**

***Общий вид функции:***
```
def index(request):
    posts = People.objects.all()  # Получаем записи из таблицы People
    cats = Category.objects.all()  # Получаем записи из таблицы Category
    context = {
        'posts': posts,
        'cats': cats,
        'menu': menu,
        'title': 'Главная страница',
        'cat_selected': 0,
    }
    return render(request, 'people/index.html', context=context)
```

**Теперь добавим переменную со значением ```0```. Почему именно ```0```? Потому что это значение будет использоваться для отображения всех записей на главной странице.**

**Проверим, как это всё работает на практике. Для этого запустим тестовый веб-сервер.**

***Всё работает корректно:***

* **Рубрика "Актрисы" теперь имеет ссылки с идентификатором значения ```1```.**
* **Рубрика "Певицы" имеет ссылки с идентификатором значения ```2```.**

**Теперь мы практически готовы к тому, чтобы отображать статьи, относящиеся к отдельным рубрикам.**

**Следующий шаг — перейти в файл ```views.py``` и модифицировать функцию ```show_category```. Вместо строки, которую она возвращает сейчас, мы сделаем так, чтобы функция выглядела следующим образом:**
```
def show_category(request, cat_id):
    posts = People.objects.filter(cat_id=cat_id) 
    cats = Category.objects.all()
    
    context = {
        'posts': posts,
        'cats': cats,
        'menu': menu,
        'title': 'Отображение по рубрикам',
        'cat_selected': cat_id,
    }
    return render(request, 'women/index.html', context=context)
```
**На этом этапе мы выбираем не все посты, а только те, которые соответствуют текущей рубрике. Это достигается благодаря фильтрации по внешнему ключу: ```cat_id```. Мы сравниваем значение внешнего ключа с идентификатором рубрики, переданным в функцию через запрос.**

**Код выглядит так:**

```posts = People.objects.filter(cat_id=cat_id)```

**Затем, чтобы отобразить список всех рубрик на странице, мы выбираем их следующим образом: ```cats = ...```**
**Дополнительно, мы передаём данные в шаблон через словарь ```context```, например:**
```
context = {
    'posts': posts,
    'cats': cats,
    ...
}
```
**Таким образом, в шаблоне мы сможем отобразить как текущую рубрику, так и список всех рубрик.**

**Теперь проверим, как всё это работает на практике:**

* **Если мы выбираем рубрику "Актрисы", то будут отображаться только посты, относящиеся к этой рубрике.**

* **Если выбираем рубрику "Певицы", а постов в этой рубрике нет, то на странице отобразится пустой список.**

****
**На данном этапе можно заметить, что в функциях представления:**
```
def show_category(request, cat_id):  
```
**и**
```
def index(request):  
```
**много общего. Они практически идентичны. Однако этот момент мы исправим позже, когда вместо функций будем использовать классы представлений и изучим пользовательские теги.**

### Внесение исправлений
***Теперь внесём пару правок для улучшения работы нашего приложения.***

***Обработка несуществующих категорий***

**Если мы используем функцию show_category из файла ```views.py``` и в браузере вводим URL с несуществующей категорией, например: http://127.0.0.1:8000/category/10/**

**То сейчас приложение возвращает страницу с пустым списком, что не является желательным поведением.**

**Будет лучше, если при отсутствии категории мы отображали бы страницу с ошибкой 404.**

**Чтобы это реализовать, перейдём в функцию ```show_category``` и добавим следующие условия:**

```
if len(posts) == 0:  
    raise Http404()
```
**Теперь, если количество постов равно 0, будет сгенерирована ошибка 404.**

### Тестирование
**Открываем в браузере категорию, в которой нет записей. Как и ожидалось, появляется страница с ошибкой 404.**

**Полностью функция выглядит так**

```
def show_category(request, cat_id):
    posts = People.objects.filter(cat_id=cat_id) 
    cats = Category.objects.all()
    
    if len(posts) == 0:
        raise Http404
    
    context = {
        'posts': posts,
        'cats': cats,
        'menu': menu,
        'title': 'Отображение по рубрикам',
        'cat_selected': cat_id,
    }
    return render(request, 'people/index.html', context=context)
```
## Добавление отображения категории и времени создания поста

**Для этого откроем шаблон ```index.html``` и добавим необходимую информацию в блок, где формируется список постов.**

***Вместо текущего:***
```
{% for p in posts %}
    <li>*Добавляем тут*
        <h2>{{ p.title }}</h2>

```
**Код должен выглядеть следующим образом:**
```
{% extends 'people/base.html' %}

{% block content %}
<ul class="list-articles">
	{% for p in posts %}
		<li>
			<div class="article-panel">
				<p class="first">Категория: {{ p.cat }}</p>
				<p class="last">Дата: {{ p.time_update|date:"d-m-Y H:i:s" }}</p>
			</div>
			<h2>{{ p.title }}</h2>
			{% autoescape on %}
			{{p.content|linebreaks|truncatewords:50}}
			{% endautoescape %}
			<div class="clear"></div>
			<p class="link-read-post"><a href="{{ p.get_absolute_url }}">Читать пост</a></p>
		</li>
	{% endfor %}
</ul>
{% endblock %}
```
### Объяснение изменений
1. **Категория: ```{{ p.cat }}```**

    * **Здесь мы отображаем название категории поста с помощью переменной ```{{ p.cat }}```.**

    * **Этот атрибут ```cat``` относится к модели ```People()``` в файле ```models.py```.**

1. **Как ```cat``` возвращает название рубрики?**

    **В модели ```People``` атрибут ```cat``` ссылается на экземпляр модели ```Category```, а метод ```__str__ ```в ```Category``` определён так:**
```
def __str__(self):
    return self.name
```
**Поэтому при обращении к ```cat``` мы видим название рубрики, так как метод ```__str__``` автоматически возвращает значение поля ```name``` из модели ```Category```.**

* **Дата: ```{{ p.time_update|date:"d-m-Y H:i:s" }}```**
* **ата отображается через атрибут ```time_update```.**
* **Мы применяем фильтр ```date``` для форматирования даты в виде:**
```"день-месяц-год часы:минуты:секунды"```.**

### Проверка
**Сохраняем изменения, переходим на главную страницу, и видим, что:**

* **Категории постов отображаются корректно.**
  
* **Дата обновления формируется в заданном формате.**


