## Формы в Django: первый шаг к интерактивным элементам

**Мы уже ознакомились с:**

* **механизмами маршрутизации;**
* **построением моделей;**
* **работой с шаблонами;**
* **использованием админ-панели.**

**Мы обязательно вернёмся к этим темам позже.
На этом занятии мы затронем новую тему — ***работа с формами***.**

**Форма — это один из ключевых элементов большинства сайтов. Например, при авторизации или регистрации мы видим страницу с полями ввода, чекбоксами, кнопками, списками и другими элементами интерфейса. Всё это и есть форма.**

**В HTML формы задаются с помощью тега ```<form>...</form>``` и предназначены для передачи пользовательской информации на сервер, например:**

* ***логин;**
* ***пароль.***

**Теперь приступим к реализации форм в фреймворке Django.**

**Подробнее о формах вы можете прочитать в [документации Django](https://ejudge.lksh.ru/lang_docs/djbook.ru/rel1.9/), в разделе ФОРМЫ. Там описано, как реализуются формы в Django.**

### Важно!

**Формы можно создавать:**

1. **В связке с моделью таблицы базы данных.**

2. **Как самостоятельные формы, без связи с моделью.**

**Чем отличаются эти типы форм?**

1. **Форма, связанная с моделью:**
    
    **Используется, когда данные формы связаны с таблицей базы данных. Пример: авторизация или регистрация, где информация пользователя сохраняется в БД.**

2. **Самостоятельная форма:**

    **Используется, когда данные формы не связаны с базой данных. Пример: форма обратной связи или форма поиска на сайте.**

***
**Мы начнем с реализации самостоятельной формы, хотя для примера будем использовать добавление статей в базу данных.**
**На следующем занятии мы модифицируем эту форму и сделаем её связанной с моделью.**

***

### Приступим к созданию формы

1. **Запустите тестовый веб-сервер и перейдите на главную страницу.**

2. **На странице есть ссылка ```"Добавить статью"``` — именно на этой странице мы создадим форму.**

**Откроем обработчик этой страницы в файле ```views.py.``` Функция, с которой будем работать, выглядит так:**

```
def addpage(request):
    return HttpResponse("Добавление статьи")
```

**Мы заменим return на следующий код:**
```
return render(request, 'people/addpage.html', {'menu': menu, 'title': 'Добавление статьи'})
```
**Таким образом, функция будет возвращать шаблон ```'women/addpage.html'```.**

**При этом мы передаем в шаблон:**

* **главное меню: ```'menu': menu;```**
* **заголовок страницы: ```'title': 'Добавление статьи'```.**

### Продолжение: создание формы и разбор её элементов

**Теперь нам нужно создать шаблон ```addpage.html``` в директории ```people/templates/people```.**

**Содержимое шаблона:**
```
{% extends 'people/base.html' %}

{% block content %}
<h1>{{ title }}</h1>
<p>Содержимое страницы</p>
{% endblock %}
```

**Что происходит в шаблоне?**

1. **Расширение базового шаблона:**

    **С помощью ```{% extends 'people/base.html' %}``` мы подключаем шаблон, который задаёт общую структуру страницы.**

2. **Блок контента:**

    **В блоке ```{% block content %}...{% endblock %}``` мы выводим заголовок ```{{ title }}```, переданный через контекст, а также создаём место для отображения формы.**

**Сохраняем изменения, переходим в браузер и обновляем страницу. Теперь у нас есть полноценная страница, где впоследствии будет отображаться форма.**
***
### Переходим к созданию формы

**В Django формы создаются на основе специального класса ```forms.Form```, который служит базой для дочерних классов.**


**Мы создадим класс формы для добавления статьи, но сначала разберём, где обычно размещаются такие классы.**

***Файл для форм***

**Обычно в приложении создаётся отдельный файл под названием ```forms.py```, где прописываются все классы форм.**

**Создаём файл ```forms.py``` в директории приложения ```people``` и прописываем в нём следующий код.**
***

***Импорты***
```
from django import forms
from .models import *
```
1. **```from django import forms```:**

    **Импортируем модуль для работы с формами.**

2. **```from .models import *```:**

    **Импортируем модели, которые могут понадобиться для создания формы, в частности, модель ```Category```.**
***

**Класс формы**
```
class AddPostForm(forms.Form):
    title = forms.CharField(max_length=255)
    slug = forms.SlugField(max_length=255)
    content = forms.CharField(widget=forms.Textarea(attrs={'cols': 60, 'rows': 10}))
    is_published = forms.BooleanField(required=False)
    cat = forms.ModelChoiceField(queryset=Category.objects.all(), empty_label="Выберите категорию")
```

**Что здесь происходит?**

1. ***Название класса:***

    **Класс ```AddPostForm``` — это имя формы, которое мы задаём сами.**
    **Он наследуется от базового класса ```forms.Form```.**

2. ***Поля формы:***
    
    **Каждое поле формы — это атрибут класса, который ссылается на соответствующий класс из ```forms```.**

    * ### *title:*
    
        **Поле для ввода заголовка статьи. Использует класс ```CharField```, задающий текстовое поле, с максимальной длиной 255 символов.**

    * ### *slug:*
    
        **Поле для ввода слага (URL-пути). Использует класс ```SlugField```, также с максимальной длиной 255 символов.**

    * ### *content:*
        
        **Поле для ввода текста статьи. Использует класс ```CharField``` с указанием виджета ```Textarea```. Виджет настраивается через атрибуты, задавая количество строк (```rows```) и столбцов (```cols```) в поле ввода.**

    * ### *is_published:*
        **Поле-чекбокс для указания, будет ли статья опубликована. Использует класс ```BooleanField```.**
        
        **Параметр ```required=False``` позволяет сделать это поле необязательным.**

    * ### *cat:*
        **Поле для выбора категории. Использует класс ```ModelChoiceField```, который формирует выпадающий список на основе объектов модели ```Category```.**

        **```queryset=Category.objects.all()```: Задаёт источник данных — все объекты из модели ```Category```.**

        **```empty_label="Выберите категорию"```: Текст, отображаемый в списке до выбора значения.**
***
### Почему мы используем только часть полей?

**Мы отображаем только те поля, которые нужны пользователю, а такие поля, как ```time_create``` и ```time_update```, заполняются автоматически и не требуют ввода.**

***
### Какие классы существуют для полей формы?
1. **```CharField```: Текстовое поле.**
2. **```SlugField```: Поле для слага (текст, пригодный для URL).**
3. **```TextField``` (в связке с виджетом ```Textarea```): Поле для многострочного текста.**
4. **```BooleanField```: Поле для чекбокса.**
5. **```ModelChoiceField```: Поле для выбора объекта из модели.**
6. **```EmailField```: Поле для ввода email.**
7. **```IntegerField```: Поле для чисел.**
8. **```DateField```: Поле для ввода даты.**
9. **```URLField```: Поле для URL.**

***
**Теперь всё готово для размещения полноценной формы на странице.
Далее мы начнём подключать эту форму к шаблону и обрабатывать данные, полученные от пользователя.**

***Полный список встроенных полей можно посмотреть также на [сайте](https://ejudge.lksh.ru/lang_docs/djbook.ru/rel1.9/#forms). Рекомендуется ознакомиться с их возможностями и применением.***

**Итак, форма определена, и её можно использовать в функции представлений в файле ```views.py``` в функции ```addpage```. Для этого создаётся экземпляр класса внутри функции:**
```
def addpage(request):
    form = AddPostForm()
    return render(request, 'people/addpage.html', {'menu': menu, 'title': "Добавление статьи"})
```
**Затем передаём её в шаблон ```addpage```. Например, у него будет ключ ```"form"```, которому присваиваем ссылку на экземпляр класса:**
```
{"form": form 'menu': menu ... }
```
**Чтобы использовать форму, её нужно импортировать. Для этого пропишем:**
```
from .forms import AddPostForm
```
**Но, чтобы не указывать конкретные классы форм, можно использовать знак ```*``` :**
```
from .forms import *
```
**Теперь функция ```addpage``` может отображать форму в шаблоне ```people/addpage.html```. Прописываем в шаблоне ```addpage.html``` следующие строки. Вместо тега абзаца ```<p>Содержимое страницы</p>``` добавляем строки кода:**
```
{% extends 'people/base.html' %}

{% block content %}
<h1>{{ title }}</h1>

<form action="{% url 'add_page' %}" method="post">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Добавить</button>
</form>

{% endblock %}
```
**Тег ```<form>``` формирует форму на HTML-странице. Атрибут ```action``` указывает URL, к которому необходимо обратиться для обработки формы, когда мы отправляем данные на сервер. В данном случае форма будет отправляться на тот же URL, где она отображается:**
```{% url 'add_page' %}```

**Атрибут ```method``` определяет способ передачи данных. Обычно для форм используется метод ```post```, так как он безопаснее: при передаче данных, таких как логин и пароль, они не отображаются в адресной строке. Для передачи изображений также рекомендуется использовать метод ```post```, так как это стандартный метод для передачи данных в Django.**

**Тег ```{% csrf_token %}``` служит для защиты формы от (Можно посмотреть тут о [CSRF-атак](https://youtu.be/OHqcFjVhro0?si=GhaDudS1jo6qD8_R)). Это важно для предотвращения случаев, когда злоумышленник создаёт форму, внешне идентичную вашей, на своём сайте. Пользователь может ввести свои данные (например, логин и пароль), которые затем перехватит злоумышленник. Чтобы этого не происходило, Django обрабатывает только те формы, которые содержат специальный токен ```csrf_token```. Этот токен генерируется каждый раз при обновлении страницы. Если токен отсутствует или не совпадает, форма обработана не будет.**

**```{{ form.as_p }}``` Позволяет отображать все поля формы, обернув их в теги абзаца ```<p>```. ```as_p``` — это метод, и шаблонизатор автоматически вызовет его в нужном месте, сформировав поля формы.**

**Завершается форма кнопкой ```<button type="submit">Добавить</button>```: Эта кнопка отправляет данные на сервер. Атрибут ```type="submit```" указывает, что это кнопка отправки формы. Текст кнопки — ```"Добавить"```.**

**Сохраняем изменения и смотрим, как всё это выглядит. Пример отображения формы:**
```
Добавление статьи
Title: [...]

Slug: [...]

Content: [...]

Is published:  [ ]

Cat: [---------]

[Добавить]

```
**Форма представлена в соответствии с описанным классом в файле ```forms.py```. Выпадающий список ```Cat``` может содержать категории, например: "Актрисы", "Певицы". Поле ```Is published``` отображается в виде чекбокса. Все элементы отображаются корректно и готовы к использованию.**

**Когда форма впервые отображается на странице, её поля пустые, так как пользователь ещё не ввёл данные. После того как он их введёт и нажмёт на кнопку "Вход", данные отправляются на сервер, где проходит проверка их корректности. Если данные верны, происходит перенаправление на другую страницу. В случае ошибок форма снова отображается пользователю, но уже с заполненными полями, чтобы не пришлось вводить данные заново.**

**Для реализации этого функционала добавим соответствующий код в функцию представления ```addpage``` в файле ```views.py```:**
```
# Страница для добавления статьи
def addpage(request):
    if request.method == "POST":
        form = AddPostForm(request.POST) # Форма с заполненными данными
        if form.is_valid(): # Проверка корректности данных
            print(form.cleaned_data) # Вывод очищенных данных в консоль
        else:
            form =AddPostForm() # Пустая форма, если данные некорректны
    else:
        form = AddPostForm() # Пустая форма для первого отображения
    
    return render(request, 'people/addpage.html', {'form': form, 'menu': menu, 'title': "Добавление статьи"})
```
**Разберём ключевые моменты:**
1. **```request.method == "POST"```
Проверяется, был ли отправлен POST-запрос (например, при нажатии кнопки "Добавить"). Если форма отправлена, создаётся объект формы с переданными данными**
2. **```AddPostForm(request.POST)```Создаёт объект формы с данными, которые пользователь ввёл на странице.**
3. **```form.is_valid()``` Проверяет корректность введённых данных. Если данные валидны, они обрабатываются (в данном случае просто выводятся в консоль с помощью ```print(form.cleaned_data)```).**
4. **Отображение пустой формы Если запрос не POST, форма создаётся пустой ```(AddPostForm()```).**
5. **Повторное отображение формы с введёнными данными. Если данные некорректны, форма повторно отображается, но уже с полями, заполненными пользователем ранее.**

***Теперь в браузере при заполнении полей формы и нажатии на кнопку "Добавить" данные передаются на сервер, где проверяются. Если они корректны, в терминале появится словарь с введёнными значениями, например:***
```
{'title': 'Шарлиз Терон', 'slug': 'sharliz-teron', 'content': 'Текст статьи', 'is_published': True, 'cat': <Category: Актрисы>}
```
**Если ввести некорректные данные (например, русские буквы в поле slug), Django автоматически отобразит ошибку:**
```
(Значение должно состоять только из латинских букв, цифр, знаков подчеркивания или дефиса.)
```
**Django предоставляет мощный встроенный функционал для валидации данных, что облегчает работу с формами и позволяет сразу сообщать пользователю об ошибках в заполнении.**


## Улучшаем внешний вид формы: шаг за шагом

1. **Поменяем заголовки полей на русский**
    
    **Первый шаг — это обновить форму, чтобы все заголовки полей стали на русском языке. Мы делаем это через параметр label, который есть у каждого поля в классе формы. Пропишем его в файле forms.py:**
    ```
    class AddPostForm(forms.Form):
        title = forms.CharField(max_length=255, label="Заголовок") 
        slug = forms.SlugField(max_length=255, label="URL")
        content = forms.CharField(widget=forms.Textarea(attrs={'cols': 60, 'rows': 10}), label="Контент")
        is_published = forms.BooleanField(label="Публикация")
        cat = forms.ModelChoiceField(queryset=Category.objects.all(), label="Категории")
    ```
    **Теперь при отображении формы на сайте, вместо стандартных англоязычных заголовков мы увидим русские: "Заголовок", "URL", "Контент", "Публикация", "Категории".**
2. **Сделаем поле ```is_published``` необязательным**

     **поле ```is_published``` мы добавим атрибут ```required=False```, чтобы оно стало необязательным для заполнения:**
    ```
    is_published = forms.BooleanField(label="Публикация", required=False)
    ```
    **Таким образом, пользователи смогут не ставить галочку в этом поле, если не хотят.**

3. **Для поля категории зададим пустое значение**
    
    **Для поля ```cat``` можно указать параметр ```empty_label```, чтобы в случае отсутствия выбора категории отображалось сообщение "Категория не выбрана":**
    ```
    cat = forms.ModelChoiceField(queryset=Category.objects.all(), label="Категории", empty_label="Категория не выбрана")
    ```
    **Этот параметр позволяет улучшить пользовательский интерфейс, предоставляя подсказку о том, что необходимо выбрать категорию.**

4. **Добавим параметр ```initial``` для поля ```is_published```**

    **Чтобы по умолчанию флажок в поле ```is_published``` был установлен (чтобы публикация была по умолчанию активирована), добавим параметр ```initial=True```:**
    ```
    is_published = forms.BooleanField(label="Публикация", required=False, initial=True)
    ```
    **Таким образом, при загрузке формы флажок будет уже установлен, что позволит пользователю быстрее заполнить форму.**

5. **Оформление формы в шаблоне ```addpage.html```**

    **Теперь, когда мы настроили параметры формы, пора перейти к оформлению страницы. В шаблоне ```addpage.html``` мы можем детально настроить отображение каждого поля.**

    **Вместо вызова функции ```{{ form.as_p }}```, которая выводит форму как простые абзацы, мы можем вручную настроить оформление каждого поля. Например, для поля ```title```:**
    ```
    <p><label class="form-label" for="{{ form.title.id_for_label }}">{{ form.title.label }}:</label>{{ form.title }}</p>
    <div class="form-error">{{ form.title.errors }}</div>
    ```
    Здесь:

* **Тег ```<label>``` получает атрибут ```for```, который связан с уникальным идентификатором поля формы, указанным как ```{{ form.title.id_for_label }}```. Django автоматически генерирует этот ID.**

* **Мы выводим сам элемент формы через ```{{ form.title }}```, чтобы в шаблоне отобразилось текстовое поле для ввода заголовка.**

* **Через ```<div class="form-error">{{ form.title.errors }}</div>``` выводим возможные ошибки для этого поля, если пользователь ввел данные некорректно.**

6. **Оформляем остальные поля формы**
   
   **По аналогии с полем ```title```, оформим остальные поля. Вот как будет выглядеть разметка для всех полей формы:**
   ```
    <p><label class="form-label" for="{{ form.slug.id_for_label }}">{{ form.slug.label }}:</label>{{ form.slug }}</p>
    <div class="form-error">{{ form.slug.errors }}</div>

    <p><label class="form-label" for="{{ form.content.id_for_label }}">{{ form.content.label }}:</label>{{ form.content }}</p>
    <div class="form-error">{{ form.content.errors }}</div>

    <p><label class="form-label" for="{{ form.is_published.id_for_label }}">{{ form.is_published.label }}:</label>{{ form.is_published }}</p>
    <div class="form-error">{{ form.is_published.errors }}</div>

    <p><label class="form-label" for="{{ form.cat.id_for_label }}">{{ form.cat.label }}:</label>{{ form.cat }}</p>
    <div class="form-error">{{ form.cat.errors }}</div>

   ```
    **В этом примере для каждого поля:**

* **Мы задаем ```label``` с привязкой к уникальному ID элемента формы через id_for_label.**

* **Используем ```{{ form.field_name }}```, чтобы отобразить сам элемент формы.**

* **Выводим ошибки, если таковые имеются, в отдельном блоке.**

7. **Как работает Django при генерации HTML**

    **Если мы посмотрим, что именно генерирует Django в браузере обводим поле и нажимаем правой кнопкой мышки и выберим посмотреть код, то увидим, например, такой фрагмент для поля ```title```:**
    ```
    <input type="text" name="title" maxlength="255" required="" id="id_title">
    ```
    ### Django сам генерирует HTML-код для текстового поля ввода. Мы видим, что:

* **```type="text"``` — это текстовое поле.**

* **```maxlength="255"``` — максимальная длина ввода.**

* **```required=""``` — поле обязательное для заполнения, так как мы не указали ```required=False.```**

* **```id="id_title"``` — уникальный идентификатор для этого поля.**

**Тег ```<label>``` также будет автоматически сгенерирован для каждого поля, благодаря привязке к ID.**

8. **Обновляем шаблон**

    **После того как мы оформили все поля, наш шаблон выглядит организованным и предоставляет нам полный контроль над тем, как будут отображаться элементы формы. Это гибкий способ оформления, который позволяет настроить внешний вид страницы и поведение полей формы в соответствии с нуждами проекта.**

    **Однако нужно учитывать, что код немного растет, поскольку для каждого поля формы мы прописываем собственный HTML-код. В большинстве случаев можно использовать автоматическое отображение с помощью ```{{ form.as_p }}```, но для сложных форм и нужд дизайна лучше использовать ручное оформление.**

## Улучшение внешнего вида формы с использованием цикла for и виджетов

**Мы заметили, что многие строки в шаблоне формы повторяются, и их можно значительно сократить, используя цикл for. Пропишем код с циклом, который будет обрабатывать все поля формы, избавив нас от необходимости дублировать строки для каждого поля.**

### Шаг 1: Используем цикл for для перебора полей

**Вместо того чтобы прописывать каждый элемент формы вручную, используем цикл for:**
```
{% for f in form %}
    <p><label class="form-label" for="{{ f.id_for_label }}">{{ f.label }}: </label>{{ f }}</p>
    <div class="form-error">{{ f.errors }}</div>
{% endfor %}
```
**Здесь цикл будет перебрать все поля формы (```form```), и для каждого поля создаст блок, содержащий метку (```label```) и сам элемент формы (```f```). Это позволяет нам избежать дублирования кода для каждого поля формы.**

### Шаг 2: Применяем виджеты для настройки стилей

**Теперь, если мы хотим присвоить каждому полю уникальные стили, это можно сделать через параметр ```widget```. Например, для поля "Заголовок" мы можем задать следующий стиль:**
```
title = forms.CharField(max_length=255, label="Заголовок", widget=forms.TextInput(attrs={"class": "form-input"}))
```
**Этот виджет будет добавлять класс "```form-input```" в HTML-элемент поля "Заголовок", что позволяет нам настроить стили для этого поля. Для остальных полей можно также задать подобные виджеты с нужными атрибутами для индивидуальной настройки внешнего вида.**

### Обработка ошибок формы

**Когда форма отправляется и проверяется на валидность, если есть ошибки, их можно вывести для каждого поля с помощью коллекции ```errors```. Для этого мы используем такой код в шаблоне ```<div class="form-error">{{ f.errors }}</div>```: Эта строка отобразит все ошибки, связанные с конкретным полем, если они есть.**

### Шаг 3: Добавление данных в базу данных

**После того как форма прошла проверку на валидность с использованием ```form.is_valid()```, можно добавить данные в базу данных. Для этого в файле ```views.py``` после проверки валидности формы, заменяем строку вывода на консоль:**

```
# print(form.cleaned_data)
```
**и добавляем код для сохранения данных в таблицу:**
```
try:
    Women.objects.create(**form.cleaned_data)
    return redirect('home')
except:
    form.add_error(None, 'Ошибка добавления поста')
```
**Здесь мы пытаемся сохранить данные в таблице ```People``` с помощью метода ```create```. Если добавление проходит успешно, выполняется редирект на главную страницу. В случае ошибки добавления мы добавляем ошибку в форму, которая будет отображена на странице.**

### Шаг 4: Отображение ошибок не связанных с полями

**Для вывода ошибок, не привязанных к конкретным полям, используем коллекцию ```non_field_errors:``` в шаблоне addpage.html**
```
    {% csrf_token %}
    
    <div class="form-error">{{ form.non_field_errors }}</div>     <---


    {% for f in form %}
```

**Это позволяет вывести общие ошибки, не связанные с конкретным полем, например, если уникальность слага в базе данных нарушена.**

## Завершение работы с формой:
**Итак, мы перешли на сайт, обновили форму и заполнили ее данными.
К примеру:**

* **В поле "Заголовок" указали: Бейонсе**
* **В поле "URL" записали: bejonse**
* **Заполнили поле "Контент", например, какой-то текст.**
* **В поле "Публикация" поставили галочку.**
* **В поле "Категории" выбрали пункт актрисы.**

**После этого нажали на кнопку Добавить, но получили ошибку:**

### "Ошибка добавления поста".
***
### *Почему это произошло?*
**Ошибка вызвана тем, что в базе данных уже существует запись с таким URL-адресом (слагом). Django автоматически проверяет уникальность поля ```slug```, и если в таблице уже есть запись с таким значением, он не позволяет сохранить новую запись.**
***
### *Как решить эту проблему?*
**Если вместо ```bejonse``` мы запишем, например, ```bejonse-2``` (добавим суффикс для уникальности), то никакой ошибки не возникнет. После этого нажимаем кнопку Добавить — форма сработала, нас перенаправило на главную страницу сайта, и мы видим новый добавленный пост.**

**Таким образом, функционал формы работает корректно, но важно учитывать уникальность полей, таких как ```slug```, чтобы избегать ошибок при добавлении данных.**
***
### *Вывод:*
**Этот пример показывает, как можно использовать формы, не связанные с моделью.**

**Для достижения результата нам пришлось:**

1. **Описать в классе ```AddPostForm``` необходимые поля, которые должны отображаться пользователю.**
2. **Вручную выполнять сохранение данных в таблицу People.**







