# Обработчик запросов в Django
### ***В Django обработка запросов осуществляется через систему представлений (views), которые отвечают за обработку входящих HTTP-запросов и возврат соответствующих HTTP-ответов. Ниже представлен обзор того, как работает обработка запросов в Django, включая создание представлений, настройку маршрутизации (URLs) и примеры использования как функциональных, так и классовых представлений.***

1. ***Основные компоненты обработки запросов в Django
URLconf (маршрутизация): Определяет, какое представление будет вызвано для определенного URL.
Представления (Views): Функции или классы, которые обрабатывают запросы и возвращают ответы.
Шаблоны (Templates): Определяют, как данные будут отображены пользователю.
Модели (Models): Представляют данные и бизнес-логику приложения.***


2. **В нашем сайте пока нет ниодного обработчика запросов. кроме тестовой главной страницы. Если мы введем код** 
```
python manage.py runserver 
```
***То увидим на тестовую веб страницу***

# Шаг 1

**Мы должны создать приложение в рамках нашего сайта которое возьмет на себя базовый функционал. Находясь в коталоге (venv) PS D:\My Dream\virtual environment\coolsite>  выполним следующую команду.**
```
    >>> (venv) PS D:\My Dream\virtual environment\coolsite> python manage.py startapp people
```

**После выполнения команды ```python manage.py startapp people``` в вашем Django-проекте создаётся новая директория с именем ```people```, содержащая стандартную структуру файлов и папок, необходимых для приложения Django. Ниже приведён список создаваемых файлов и их назначение:**

* *Структура создаваемого приложения people*
    
    ```
    people/
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── migrations/
    │   └── __init__.py
    ├── models.py
    ├── tests.py
    └── views.py
    ```
    
* *Описание создаваемых файлов и папок*
1. **```people/``` Корневая директория вашего нового приложения.**

2. ```__init__.py``` **Пустой файл, который указывает Python, что данная директория является пакетом. Это необходимо для правильного обнаружения и импорта модулей внутри приложения.**

3. ```admin.py``` **Файл для настройки административного интерфейса Django для вашего приложения. Здесь вы можете регистрировать модели, чтобы управлять ими через панель администратора.**
    ```
    from django.contrib import admin
    from .models import YourModel

    admin.site.register(YourModel)
    ```
4. ```apps.py``` **Файл конфигурации приложения. Содержит класс конфигурации, который используется Django для настройки приложения.**
    ```
    from django.apps import AppConfig

    class PeopleConfig(AppConfig):
        default_auto_field = 'django.db.models.BigAutoField'
        name = 'people'
    ```
5. ```migrations/``` **Папка для хранения миграций базы данных, связанных с моделями вашего приложения.**

6. ```__init__.py``` **Пустой файл для обозначения папки как Python-пакета.**

7. ```models.py``` **Файл для определения моделей вашего приложения. Здесь вы описываете структуры данных и их взаимодействие с базой данных.**
    ```
    from django.db import models
    ```
7. ```tests.py``` **Файл для написания тестов вашего приложения. Здесь вы можете создавать тестовые кейсы для проверки корректности работы ваших моделей, представлений и других компонентов.**
    ```
    from django.test import TestCase
    ```

8. ```views.py``` **Файл для создания представлений (views) вашего приложения. Представления отвечают за обработку запросов и возврат ответов пользователю.**
    ```
    from django.shortcuts import render
    ```

### Заключение

***Команда ```startapp``` автоматически создаёт базовую структуру, необходимую для начала разработки приложения в Django. Отсюда вы можете расширять функциональность, добавляя модели, представления, шаблоны, статические файлы и другие компоненты в зависимости от требований вашего проекта.***



## Регестрируем наше приложение 'people' в проекте нашего сайта.


***Отлично, мы успешно создали новое приложение ```people``` в вашем Django-проекте. Теперь необходимо зарегистрировать это приложение в проекте, чтобы Django знал о его существовании и мог корректно взаимодействовать с ним. Ниже приведено подробное руководство по регистрации приложения people в вашем проекте Django.***

### Шаг 1: Открытие файла настроек проекта (```settings.py```)

**Каждый Django-проект содержит файл настроек ```settings.py```, который управляет конфигурацией проекта, включая установленные приложения, базы данных, шаблоны и другие параметры.**

* **Найдем файл ```settings.py```:**

**Обычно он находится в директории проекта, например, если ваш проект называется coolsite, путь будет примерно таким:**
```
coolsite/
├── coolsite/
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
└── people/
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── migrations/
    ├── models.py
    ├── tests.py
    └── views.py
```

**Откроем ```settings.py```.**

### Шаг 2: Добавление приложения people в ```INSTALLED_APPS```

```INSTALLED_APPS``` **— это список всех приложений, установленных в вашем Django-проекте. Django использует этот список для настройки различных компонентов, таких как модели, миграции, административный интерфейс и другие.**

**Найдем раздел ```INSTALLED_APPS``` в ```settings.py```. Он выглядит примерно так:**
```
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Добавьте сюда наше приложение
]
```

**Добавим наше приложение ```people``` в этот список. Есть два способа сделать это:**

* **Способ 1: Добавление по имени приложения**

**Просто добавьте строку ```'people'```, в список ```INSTALLED_APPS```:**
```
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'people',  # Наше приложение
]
```
* **Способ 2: Использование полного пути к классу конфигурации приложения**

**В файле ```people/apps.py``` по умолчанию уже создан класс конфигурации приложения. Вы можете добавить приложение, указав полный путь к этому классу:**
```
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'people.apps.PeopleConfig',  # Полный путь к конфигурации приложения
]
```
***Этот способ предпочтителен, так как позволяет более гибко настраивать приложение через класс конфигурации.***

### Шаг 3: Сохранение изменений и проверка конфигурации

**Сохраните изменения в ```settings.py```.**

## Переходим в файл ```views.py``` и создаем предстовление.

**Пропишим следующую функцию.** 

```
from django.http import HttpResponse
from django.shortcuts import render

def index(request):
    return HttpResponse("Страница приложения celebrities")
```

**Эта функция называется ```index```, и она является представлением (```view```) в Django. Вот подробное объяснение ее работы:**

1. **Импорт необходимых модулей:**

    * **```HttpResponse``` используется для отправки HTTP-ответов клиенту.**
  
    * **```render``` — это функция, которая обычно используется для рендеринга шаблонов, но в данном случае она не используется.**

2. **Определение функции ```index```:**

    * **Функция принимает один параметр — ```request```, который представляет объект HTTP-запрос. Этот объект содержит всю информацию о запросе, сделанном клиентом (например, параметры запроса, заголовки и т. д.).**

3. **Возвращение ответа:**

    * **Внутри функции возвращается объект ```HttpResponse``` с текстом "Страница приложения celebrities". Это означает, что когда пользователь обращается к URL, связанному с этой функцией, он получит простой текстовый ответ, который будет отображаться в веб-браузере.**

## Связываем эту функцию с URL-адресом.

**Как это работает в Django:**

**Для того чтобы эта функция сработала, она должна быть связана с определенным URL в вашем файле маршрутов (```urls.py```). Например:**
```
from django.contrib import admin
from django.urls import path

from people.views import index

urlpatterns = [
    path('admin/', admin.site.urls),
    path('people/', index)
]
```

**Теперь, когда пользователь переходит на корневой URL вашего приложения, он увидит текст "Страница приложения people".**

**После стандартног запуска мы видем ошибку которая указывает что адрес был указан не верно. Адрес находится  на http://127.0.0.1:8000/people/, Уже тут отображается сообщение из файла ```views.py``` ```"Страница приложения people"```
Все довольно просто, и в рамках приложения ```people```, можем определять сколько угодно таких функций связанные с разными URl-адресами.**

**Прописываем еще одну функцию - отоброжение списка статей по рубрикам(```views.py```); Доп, укажим тег ```<h1></h1>``` для того чтобы браузер отобразил эту строку как заголовок первого уровня.**
```
def categories(request):
    return HttpResponse("<h1>Статьи по категориям</h1>")
```

***Далее мы должны перейти ```coolsite/coolsite/urls.py``` и прописать сюда еще один маршрут. к примеру назавем ее ```cats/``` и должны указать функцию предстовления которая будет обрабатывать этот запрос это у нас функция categories**
```
path('cats/', categories), # http://127.0.0.1:8000/cats/
```
**и так же импортируем categories.**

Теперь можно перейти на сайт и запишим наш запрос http://127.0.0.1:8000/cats/

**Когда мы переходим на тестовую страницу нашего приложения, может возникнуть ошибка ```"Page not found (404)"```. Это связано с тем, что маршрут к главной странице не прописан.**

**Чтобы указать маршрут к главной странице, в файле ```urls.py``` заменим часть ```path('people/', index)``` на ```path('', index)```. Теперь функция ```index``` будет обрабатывать запросы на главную страницу сайта. После сохранения изменений и обновления страницы мы увидим сообщение: ```"Страница приложения people"```.**

**Однако такой подход, при котором маршруты приложения прописываются в основном файле конфигурации ```urls.py```, нарушает принцип независимости приложений. Если в будущем нам потребуется перенести приложение в другой проект, придется дополнительно копировать маршруты из основного файла ```urls.py```, что неудобно и не соответствует лучшим практикам.**

**Для решения этой проблемы Django позволяет вместо функции представления передавать вторым параметром функцию ```include()```, которая подключает список URL-адресов, определённых в самом приложении.**

**Использование ```include()``` позволяет хранить маршруты приложения в его собственном файле ```urls.py```, что повышает независимость и переносимость приложения.**
```
from django.urls import path, include

А вместо теперь дынных строк 

path('people/', index)
path('cats/', categories),
```
**Мы можем указать всего одну строку**

**В Django функция ```path()``` используется для определения маршрутов (URL patterns) в вашем приложении. В частности, строка:**
```
path('people/', include('people.urls'))
```


**Разбор строки ```path('people/'```, ```include('people.urls'))```**

1. **```path:```**

    * **Это функция из модуля django.urls, используемая для определения маршрутов URL в Django.**
    **Синтаксис: path(route, view, kwargs=None, name=None)**

2. ```**'people/'**```:

    * **Это URL-путь (маршрут), с которым будет сопоставляться запрос.**
    
    * **В данном случае, все URL, начинающиеся с ```people/```, будут обрабатываться маршрутами, определёнными в модуле people.urls.**

3. **include(```'people.urls'```):**

    * **Функция ```include``` позволяет подключать другие модули конфигурации URL.**
    
    * **В данном случае, она указывает Django искать файл ```urls.py``` внутри приложения ```people``` и использовать его маршруты для обработки URL, начинающихся с ```people/```.**

***
**Теперь создадим файл ```urls.py``` в папке нашего приложения ```people/```.``` Этот файл будет содержать маршруты для приложения. Вот его содержимое:**
```
from django.urls import path

from .views import * 

urlpatterns = [
    path('', index)
]
```
*В этом коде:*

**Импортируется модуль ```views``` из текущего приложения. ```urlpatterns``` содержит список маршрутов, где путь '' (пустая строка) указывает на корневой маршрут для приложения ```people```. При переходе на этот маршрут будет вызвана функция ```index``` из файла ```views.py```. Маршрут также имеет имя ```index```, что удобно для обращения к нему в шаблонах и коде.**

**Эта строка будет выдавать маршрут http://127.0.0.1:8000/people/, потому что в основном ```urls.py``` проекта был указан путь ```path('people/', include('people.urls'))```. Это означает, что все маршруты внутри ```people/urls.py``` будут начинаться с префикса ```people/```. В данном случае, пустая строка указывает на корневой маршрут внутри этого префикса, т.е. ```people/```.**


### ***Создание двух файлов ```urls.py``` (один в главной папке проекта ```coolsite``` и другой в папке приложения, например, ```people/```) является стандартной практикой в Django для модульности и упрощения поддержки кода. Вот основные причины:***

- ***1.*** *Модульность и масштабируемость: Каждый файл ```urls.py``` в приложении отвечает за маршруты, связанные только с этим конкретным приложением. Это позволяет масштабировать проект, добавляя новые приложения с собственными маршрутами, не изменяя главный файл ```urls.py```.*

- ***2.*** *Разделение ответственности: Главный ```urls.py``` в ```coolsite``` отвечает за маршруты верхнего уровня и за подключение отдельных приложений, а файлы ```urls.py``` внутри приложений содержат более детализированные маршруты для этих приложений.*

- ***3.*** *Упрощение структуры проекта: Если все маршруты будут храниться в одном файле, то с ростом проекта этот файл станет слишком громоздким. Разделение маршрутов на несколько файлов делает структуру проекта более организованной и удобной для сопровождения.*

- ***4.*** *Переиспользование приложений: Django поощряет создание независимых приложений, которые могут быть использованы в других проектах. Наличие собственного файла ```urls.py``` в каждом приложении позволяет легко интегрировать это приложение в другие проекты.*

***Таким образом, наличие двух (или более) ```urls.py``` файлов в проекте помогает поддерживать код организованным и легким в сопровождении.***

