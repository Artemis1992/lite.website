## Использование классов представлений вместо функций в Django

**Ранее в проекте мы использовали функции для обработки запросов. Это простой и удобный подход, особенно если требуется реализовать простую логику. Однако Django поддерживает и другой подход — использование классов представлений (Class-Based Views, сокращённо CBV). Этот объектно-ориентированный подход часто упрощает код, делая его более понятным и читаемым.**

**Чтобы получить полное представление о классах представлений и их использовании, сначала рекомендуется ознакомиться с документацией по следующим ссылкам:**

1. ***[Общий обзор слоя представлений](https://ejudge.lksh.ru/lang_docs/djbook.ru/rel1.9/#the-view-layer)***
2. ***[Базовые классы представлений](https://ejudge.lksh.ru/lang_docs/djbook.ru/rel1.9/ref/class-based-views/index.html)***

    **Здесь представлен список базовых классов представлений, на основе которых можно создавать собственные представления для обработки запросов.**
***

### Переход на класс представления в проекте

**Теперь создадим класс представления вместо функции ```index```. Напомним, что функция ```index``` отвечает за главную страницу сайта и отображает список статей.**

### 1. **Импортируем класс ```ListView```**

**Класс ```ListView``` создаёт список объектов. Импортируем его в файле ```views.py```:**
    
    
    from django.views.generic import ListView
    

### 2. **Создаём класс представления**
    
    
***Под переменной ```menu``` создаём класс ```PeopleHome```, который будет использоваться для главной страницы сайта.***

    
    class PeopleHome(ListView):
        model = People
    

**Этот класс основан на базовом классе ```ListView``` и связан с моделью ```People```. Атрибут ```model = People``` выбирает все записи из таблицы ```People``` и отображает их в виде списка.**
***
### Логика поиска шаблона

**Класс ```ListView``` по умолчанию ищет шаблон в следующем формате:**

```<Имя приложения>/<Имя модели>_list.html```

**В нашем случае это будет шаблон ```people/people_list.html```. Мы пока не будем его создавать, а оставим класс в таком виде:**
```
class PeopleHome(ListView):
    model = People
```
**Задокументируем функцию ```index```. Для проверки работы класса представления временно закомментируем функцию ```index```:**
```
# # Главная страница, отображает все записи
# def index(request):
#     posts = People.objects.all()  # Получаем все записи из модели People
#     context = {
#         'posts': posts,        # Список записей
#         'title': 'Главная страница',  # Заголовок страницы
#         'cat_selected': 0,     # Выбранная категория (0 — все категории)
#     }
#     return render(request, 'people/index.html', context=context)

```
***
### Подключение класса представления в маршрутах

**В файле ```urls.py``` заменяем функцию ```index``` на наш класс представления:**
```
from .views import * 

urlpatterns = [
    path('', PeopleHome.as_view(), name='home'),  # Главная страница
    ...
]
```
**Обратите внимание на вызов метода ```as_view()```. Он обязателен для связи класса представления с маршрутом.**
***
### Настройка шаблона

**Если мы перейдём на главную страницу, получим ошибку, так как шаблон ```people/people_list.html``` отсутствует. Мы могли бы создать этот шаблон, но вместо этого укажем в классе ```PeopleHome``` использование существующего шаблона index.html.**

*Добавим в класс атрибут:*
```
class PeopleHome(ListView):
    model = People
    template_name = "people/index.html" # Вместо создание нового шаблона указываем старый.
```
**После обновления страницы мы увидим пустую страницу. Это связано с тем, что в шаблоне ```index.html``` используется коллекция ```posts```, а класс представления ```PeopleHome``` автоматически формирует другую коллекцию — ```object_list```. Чтобы шаблон заработал, нужно обновить цикл в шаблоне:**
```
{% block content %}
<ul class="list-articles">
    {% for p in object_list %}         <-----------
            <div class="article-panel">
                <!-- Отображение категории текущей статьи -->
```
***
### Использование переменной ```posts```

**Если мы хотим оставить в шаблоне переменную ```posts```, то необходимо явно указать её в классе ```PeopleHome```. Добавим следующий атрибут:**
```
class PeopleHome(ListView):
    model = People
    template_name = "people/index.html" # Вместо создание нового шаблона указываем старый.
    context_object_name = "posts" # Для того чтобы оставить posts в шаблолне index.html, явно указываем ее. 

```
***

**Для того чтобы добавить заголовок ```title``` и главное меню на главную страницу, нам нужно доработать класс представления ```PeopleHome`` и заменить использование атрибута ```extra_context`` на метод ```get_context_data```, который позволяет формировать как статический, так и динамический контекст для передачи в шаблон.**

***

### Доработка класса PeopleHome
1. **Добавляем заголовок ```title```:**
    
    **Самый простой способ — использовать атрибут ```extra_context```, однако он ограничен только передачей статических данных (строк, чисел). Для большей гибкости мы будем использовать метод ```get_context_data```.**

2. **Передача главного меню ```menu```:**
    
    **Главное меню — это динамический список, и его нельзя передать через ```extra_context```. Поэтому мы дополним метод ```get_context_data```, чтобы добавить меню в контекст.**

## Итоговый код класса PeopleHome
```
class PeopleHome(ListView):
    model = People
    template_name = "people/index.html" # Вместо создание нового шаблона указываем старый.
    context_object_name = "posts" # Для того чтобы оставить posts в шаблолне index.html, явно указываем ее. 

    # Формирование контекста
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs) # Получаем базовый контекст от родительского класса
        context['menu'] = menu
        context['title'] = 'Главная страница'
        return context
```
## Разбор метода ```get_context_data```
1. **```super().get_context_data(**kwargs)```**
    
    **Этот вызов возвращает текущий контекст, сформированный базовым классом ```ListView``. Мы используем его, чтобы сохранить стандартные параметры и дополнить их своими.**
2. **Добавление ```menu```:**
   
   ```context['menu'] = menu```

   **Здесь ключ ```'menu'``` становится доступным в шаблоне, а значением является список ```menu```, который мы заранее определили.**

3. **Добавление ```title```:**

    ```context['title'] = "Главная страница"```
    
    **Ключ ```'title'``` содержит строку "Главная страница" для использования в шаблоне, например, в HTML-теге ```<title>```.**

4. ```return context:```
    
    **Возвращаем дополненный контекст, который затем будет передан в шаблон.**

***
## Проверка работы
1. **Перейдите на главную страницу.**

2. **Убедитесь, что заголовок страницы отображается как "Главная страница" во вкладке браузера.**

3. **Проверьте, что главное меню динамически отображается на странице.**

## Добавление параметра «Все категории»
**Для того чтобы в шаблон передать параметр, позволяющий выбирать категорию «Все категории», нужно дополнить класс PeopleHome следующим образом:**
```
class PeopleHome(ListView):
    model = People
    template_name = "people/index.html" # Вместо создание нового шаблона указываем старый.
    context_object_name = "posts" # Для того чтобы оставить posts в шаблолне index.html, явно указываем ее. 

    # Формирование контекста
    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs) # Получаем базовый контекст от родительского класса
        context['menu'] = menu
        context['title'] = 'Главная страница'
        context['cat_selected'] = 0
        return context
```
**Метод ```get_context_data``` используется для передачи дополнительных параметров в шаблон. В данном случае мы добавили ```cat_selected``` со значением ```0```, что означает, что выбрана категория «Все категории». После обновления страницы «Все категории» будут корректно выделены.**
***
### Отображение только опубликованных статей

**Чтобы на главной странице отображались только опубликованные статьи, необходимо добавить метод ```get_queryset``` в класс ```PeopleHome```. Этот метод позволяет выбирать записи, которые должны быть показаны.**
```
class PeopleHome(ListView):
    model = People
    template_name = "people/index.html" # Вместо создание нового шаблона указываем старый.
    context_object_name = "posts" # Для того чтобы оставить posts в шаблолне index.html, явно указываем ее. 

    # Формирование контекста
    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs) # Получаем базовый контекст от родительского класса
        context['menu'] = menu
        context['title'] = 'Главная страница'
        context['cat_selected'] = 0
        return context
    
    def get_queryset(self):
        return People.objects.filter(is_published=True)
```
**Теперь отображаются только те статьи, у которых в базе данных поле ```is_published``` установлено в значение ```True```. Если снять галочку «Опубликовано» для некоторых статей в админке, они перестанут отображаться на главной странице**
***

### Создание класса для отображения категорий

**Для реализации отображения статей по категориям заменим функцию ```show_category``` на класс-представление. Исходная функция выглядит так:**
```
# Отображение постов по категории
def show_category(request, cat_id):
    posts = People.objects.filter(cat_id=cat_id)  # Получаем посты по категории

    if len(posts) == 0:
        raise Http404  # Если посты не найдены, генерируем ошибку 404
    
    context = {
        'posts': posts,
        'title': 'Отображение по рубрикам',
        'cat_selected': cat_id,
    }
    return render(request, 'people/index.html', context=context)
```
**Закомментируем её и создадим класс PeopleCategory:**
```
class PeopleCategory(ListView):
    model = People
    template_name = 'people/index.html'
    context_object_name = 'posts'
    
    def get_queryset(self):
        return People.objects.filter(cat__slug=self.kwargs['cat_slug'], is_published=True)
```
### Пояснение к коду:

1. **Наследование от ```ListView```**
   
    **Класс ```PeopleCategory``` наследуется от базового класса ```ListView```, так как это тоже будет список статей.**

2. **Атрибут ```model```**
   
    **Указывает модель, с которой работает класс. В данном случае это People.**

3. **Атрибут ```template_name```**
    
    **Используется для указания пути к шаблону, в котором будет отображаться список статей.**

4. **Атрибут ```context_object_name```**
    
    **Позволяет в шаблоне обращаться к списку статей через переменную ```posts```.**

5. **Метод ```get_queryset```**
    
    **Этот метод определяет, какие именно записи из базы данных должны быть выбраны. В данном случае выбираются статьи, соответствующие категории по слагу ```cat_slug```, и только опубликованные (```is_published=True```).**

### Работа с маршрутом 

**В файле ```urls.py``` нужно прописать маршрут для этого класса. Вместо функции ```show_category``` используем наш класс-представление:**
```
path('category/<slug:cat_slug>/', PeopleCategory.as_view(), name='category'),
```
**Обратите внимание на использование метода ```as_view()``` — он необходим для связи класса с маршрутом. Параметр ```<slug:cat_slug>``` позволяет получать слаг категории из URL.**
***

## Пояснение к параметру ```cat__slug```

**Запись ```cat__slug=self.kwargs['cat_slug']``` означает, что фильтрация происходит по полю ```slug``` связанной категории ```cat```. Здесь ```cat``` — это внешний ключ в модели ```People```, указывающий на модель ```Category```, а ```slug``` — поле в модели ```Category```. Мы будем рассматривать подобные конструкции подробнее при изучении Django ORM.**
***
## Работа с категориями и постами в Django: от моделей до представлений

### Привязка категории через ```cat__slug``` в ```views.py```

**В файле ```models.py``` у нас есть модель ```People```, в которой имеется атрибут ```cat```, ссылающийся на модель ```Category```. Когда мы работаем с категориями в ```views.py```, мы используем параметр ```cat__slug```, который обращается к полю ```slug``` в таблице категорий, связанной с текущей записью.**

**Изменение маршрута в ```urls.py```**

**Чтобы правильно привязать класс представления, нам нужно заменить строку ```show_category``` на ```PeopleCategory.as_view()``` в файле ```urls.py```. Мы связываем маршрут ```category/<slug:cat_slug>/``` с классом представления. Это важно, чтобы URL включал именно ```slug``` категории, а не ```id```, который раньше использовался.**

**Исправление метода ```get_absolute_url```  в модели**

**В 14 конспекте мы описывали метод ```get_absolute_url``` в модели ```People```. Он выглядел так**
```
return reverse('category', kwargs={'cat_id': self.pk})
```
**Это приводило к ошибке, потому что маршрут ожидал ```cat_slug```, а не ```cat_id```. Ошибка была следующей:**
```
Reverse for 'category' with keyword arguments '{'cat_id': 1}' not found.  
1 pattern(s) tried: ['category/(?P<cat_slug>[-a-zA-Z0-9_]+)/\\Z']
```
**Чтобы исправить это, мы изменили метод на;**
```
return reverse('category', kwargs={'cat_slug': self.slug})
```

**Теперь вместо ```id``` используется ```slug```, и URL формируется корректно.**

**Добавление метода ```get_context_data``` в представление**

**Теперь нам нужно передавать в контекст дополнительные данные, такие как заголовок страницы и выделение выбранной категории. Для этого мы добавляем метод ```get_context_data``` в класс представления ```PeopleCategory``` в файле ```views.py```:**
```
class PeopleCategory(ListView):
    model = People
    template_name = 'people/index.html'
    context_object_name = 'posts'
    

    def get_context_data(self, *, object_list=None, **kwargs):
        context =  super().get_context_data(**kwargs)
        context['title'] = 'Категория - ' + str(context['posts'][0].cat)
        context['menu'] = menu
        context['cat_selected'] = context['posts'][0].cat_id
        return context
    

    def get_queryset(self):
        return People.objects.filter(cat__slug=self.kwargs['cat_slug'], is_published=True)
```
**Итоговый контекст в шаблоне**
**Контекст, передаваемый в шаблон, будет выглядеть примерно так:**
```
{
    'posts': [...],  # Список объектов People
    'title': 'Категория - <название категории>',
    'menu': [...],   # Навигационное меню
    'cat_selected': <id текущей категории>,
}
```
**Здесь мы формируем заголовок страницы, добавляя к строке 'Категория - ' название категории из первого поста в списке ```posts```. Также передаем в контекст меню и ```id``` выбранной категории.**

### Обработка ошибки при отсутствии записей

**Если мы пытаемся обратиться к категории, которая не существует (например, по невалидному ```slug```), возникает ошибка ```IndexError```, так как в списке ```posts``` нет элементов. Чтобы избежать этой ошибки и вместо этого отобразить страницу 404, мы используем атрибут ```allow_empty = False``` в классе ```PeopleCategory```. Это гарантирует, что если категория не найдена, будет сгенерирована ошибка 404.**
```
class PeopleCategory(ListView):
    model = People
    template_name = 'people/index.html'
    context_object_name = 'posts'
    allow_empty = False
```

**Правило для ```allow_empty```**

**Атрибут ```allow_empty``` в Django используется для определения, как обрабатывать пустые списки:**

* **Если ```allow_empty = True```, то будет показана пустая страница с сообщением "Нет результатов".**
* **Если ```allow_empty = False```, то Django сгенерирует ошибку 404, если не найдено ни одной записи для данной категории.**

### Переход к классу ```ShowPost```

**Для отображения отдельного поста мы решили заменить функцию ```show_post``` на класс представления ```ShowPost```, который будет наследовать ```DetailView```. Это позволит нам использовать Django's класс представления для отображения одного поста:**
```
class ShowPost(DetailView):
    model = People
    template_name = "people/post.html"
```
**Импортируем класс ```DetailView```**
```
from django.views.generic import ListView, DetailView
```

**Теперь для отображения отдельного поста вместо функции ```show_post``` используем класс с методом ```ShowPost.as_view()```.**

### Проблема с именованием параметра ```slug``` в URL

**В файле ```urls.py``` маршрут для отображения поста был следующим:**
```
path('post/<slug:post_slug>/', show_post, name='post')
```
**Но класс ```DetailView``` по умолчанию ожидает параметр ```slug```, а не ```post_slug```. Чтобы использовать именно ```post_slug```, мы добавляем атрибут ```slug_url_kwarg = "post_slug"``` в наш класс ShowPost:**
```
class ShowPost(DetailView):
    model = People
    template_name = "people/post.html"
    slug_url_kwarg = "post_slug"
```
**Теперь в представлении будет использоваться именно параметр ```post_slug``` из URL, как и требовалось.**

***И так же меняем маршрут в ```urls.py```. превязываем класс к маршруту ```posts```***
```
path('post/<slug:post_slug>/', ShowPost.as_view(), name='post'), #Посты
```

**Использование ```context_object_name``**

**Чтобы правильно отобразить данные модели в шаблоне, нам нужно указать, в какую переменную будет помещен объект. Для этого мы используем атрибут ```context_object_name```. В нашем случае мы хотим, чтобы объект был доступен в шаблоне как ```post```. Для этого добавляем:**
```
context_object_name = "post"
```
***Обновление ```get_context_data``` для ```ShowPost```***

**Нам также нужно обновить метод ```get_context_data``` в классе ```ShowPost```, чтобы передать правильный заголовок страницы и меню:**
```
    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = context['post']
        context['menu'] = menu
        return context
```
**Теперь на странице поста будет отображаться заголовок из поля title модели Women и главное меню.**


## Добавление нового поста с использованием класса CreateView

**Для упрощения работы с формами в Django мы заменим функцию ```addpage``` на класс представления ```AddPage```, который наследуется от ```CreateView```.**

**Импорт класса ```CreateView```**

**Сначала добавим в начале файла ```views.py``` импорт ```CreateView```:**
```
from django.views.generic import ListView, DetailView, CreateView
```

**Преобразование функции в класс**

**Ранее для добавления нового поста мы использовали функцию ```addpage``` Теперь мы закомментируем эту функцию и создадим класс ```AddPage``` на основе ```CreateView```:**
```
class AddPage(CreateView):
    form_class = AddPostForm
    template_name = "people/addpage.html"
```
* **```form_class```: Указывает на класс формы ```AddPostForm```, который связан с моделью.**

* **```template_name```: Определяет шаблон, который будет использоваться для отображения формы.**

***Связывание класса с маршрутом***

**В файле ```urls.py``` добавим маршрут, который связывает URL ```/addpage/``` с классом ```AddPage```:**
```
path('addpage/', AddPage.as_view(), name='add_page'),
```
**После этого, при переходе на страницу добавления статьи, форма отобразится, но меню может отсутствовать.**

**Добавление меню через метод ```get_context_data```**

**Чтобы вернуть меню на страницу, добавим метод get_context_data в класс AddPage:**
```
def get_context_data(self, *, object_list=None, **kwargs):
    context = super().get_context_data(**kwargs)
    context['title'] = "Добавление статьи"
    context['menu'] = menu
    return context
```
*Этот метод:*

* **Наследует базовый контекст с помощью ```super().get_context_data(**kwargs)```.**

* **Добавляет заголовок страницы и главное меню в контекст.**

***Теперь меню будет отображаться корректно.***

**Преимущества использования классов представлений**

**Сравним код функции и класса:**

### *Функция ```addpage```:*
```
def addpage(request):
    # Если запрос был отправлен методом POST (пользователь отправил форму)
    if request.method == "POST":
        form = AddPostForm(request.POST, request.FILES) # Форма с заполненными данными
        if form.is_valid(): # Проверяем, валидны ли данные, введённые пользователем
            # Перенаправляем пользователя на главную страницу после успешного добавления
            form.save()
            return redirect("home")
    else:# Если пользователь просто открыл страницу
        form = AddPostForm() # Создаём пустую форму
    # Возвращаем шаблон `addpage.html`, передавая форму, меню и заголовок страницы
    return render(request, 'people/addpage.html', {
        'form': form, 
        'menu': menu, 
        'title': "Добавление статьи"
    })
```
### *Класс AddPage:*
```
class AddPage(CreateView):
    form_class = AddPostForm
    template_name = "people/addpage.html"
    
    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = "Добавление статьи"
        context['menu'] = menu
        return context
```
*Преимущества класса:*

1. *Код компактнее: Использование классов позволяет сократить объем кода.*

2. *Переиспользование: Метод ```get_context_data``` можно вынести в базовый класс и использовать в других представлениях.*

3. *Простота настройки: Всего несколько атрибутов (```form_class```, ```template_name```) заменяют ручную обработку запросов.*

***Результат***

***После добавления класса и маршрута:***

1. *Переход на страницу ```/addpage/``` отобразит форму для добавления статьи.*
   
2. *После сохранения статьи вы будете перенаправлены на страницу новой статьи.*

3. *Новая статья отобразится в списке всех записей и в выбранной категории.*
   
**Использование классов представлений делает процесс создания форм в Django значительно проще и удобнее. Теперь попробуйте добавить новую статью через форму, чтобы убедиться, что все работает корректно.**









