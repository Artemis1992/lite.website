## Механизм авторизации в Django

**Когда пользователь отправляет запрос на сервер, Django проверяет, авторизован ли он. Если пользователь ранее прошёл авторизацию, информация о его сеансе сохраняется в cookies и базе данных сессий. При следующем запросе Django автоматически извлекает данные из сессии и идентифицирует пользователя. Это избавляет его от необходимости вводить логин и пароль при каждом запросе.**

**Если пользователь не авторизован, ему необходимо пройти процедуру входа. Это реализуется через форму авторизации, где он вводит свои учетные данные (логин и пароль). Django сравнивает их с данными в базе и, если они корректны, создаёт сессию, привязанную к пользователю.**

**Теперь перейдём к коду, который реализует этот механизм.**

### Код представления для авторизации пользователя

**В файле ```views.py``` добавляется класс ```LoginUser```, который отвечает за отображение формы авторизации.**

```
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth.views import LoginView

class LoginUser(DataMixin, LoginView):
    from_class = AuthenticationForm
    template_name = 'people/login.html'
    
    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)
        c_def = self.get_user_context(title='Авторизация')
        return dict(list(context.items()) + list(c_def.items()))
```

## Разбор кода

1. **Импорт необходимых классов:**

    * **```AuthenticationForm``` — стандартная форма Django для аутентификации пользователей.**
    * **```LoginView``` — встроенный Django-класс для обработки авторизации.**

2. **Определение класса ```LoginUser```:**

    * **Наследуется от ```LoginView```, что позволяет использовать стандартный механизм авторизации Django.**
    * **Также наследуется от DataMixin, который, вероятно, добавляет дополнительные данные в контекст.**

3. **Атрибут ```from_class = AuthenticationForm```:**

    * **Указывает, что в этом представлении используется форма ```AuthenticationForm```, предназначенная для ввода логина и пароля.**

4. **Атрибут ```template_name = 'people/login.html'```:**

**Определяет шаблон, который будет отображаться при запросе страницы авторизации.**

5. **Метод ```get_context_data```:**

    * **Получает контекст из родительского класса ```LoginView```.**

    * **Добавляет к нему дополнительные данные с помощью метода ```self.get_user_context(title='Авторизация')```.**

    * **Итоговый словарь объединяет стандартный контекст и дополнительные параметры.**

## Процесс работы

1. **Пользователь открывает страницу /login/.**

2. **Django вызывает LoginUser, который загружает people/login.html.**

3. **Форма аутентификации AuthenticationForm отображается пользователю.**

4. **После отправки формы Django проверяет логин и пароль.**

5. **Если данные верны, Django создаёт сессию и перенаправляет пользователя на указанную страницу.**

6. **Если данные неверны, пользователь остаётся на странице авторизации и видит сообщение об ошибке.**

***

### теперь следующим шагом и создадим шаблон login.html тот который мы указали в классе LoginUser. 

```
{% extends 'people/base.html' %}

{% block content %}
    <h1 class="center-title">{{ title }}</h1>

    <div class="form-container">
        <form method="post" autocomplete="off">
            {% csrf_token %}

            {% for f in form %}
                <div class="form-group">
                    <label class="form-label" for="{{ f.id_for_label }}">
                        {% if f.name == 'username' %}
                            Login:
                        {% elif f.name == 'password' %}
                            Password:
                        {% else %}
                            {{ f.label }}
                        {% endif %}
                    </label>

                    <div class="form-field password-container">
                        <input type="{% if f.name in 'password' %}password{% else %}text{% endif %}" 
                               name="{{ f.name }}" id="{{ f.id_for_label }}" class="form-field-input"
                               autocomplete="new-password"
                               placeholder="{% if f.name == 'username' %}Имя{% else %}{{ f.label }}{% endif %}" />

                        {% if f.name in 'password1' %}
                            <!-- Чекбокс для показа пароля -->
                            <div class="show-password-container">
                                <label class="clickable-label">
                                    <input type="checkbox" class="show-password" onclick="togglePassword(this)">
                                    Показать&#8203;пароль&#8203;
                                </label>
                            </div>
                        {% endif %}
                    </div>

                    {% if f.errors %}
                        <div class="form-error">
                            {% for error in f.errors %}
                                <p class="error-message">{{ error }}</p>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
            {% endfor %}

            <button type="submit" class="submit-btn">Вход</button>
        </form>
    </div>

    <script>
        function togglePassword(checkbox) {
            let input = checkbox.closest('.password-container').querySelector('.form-field-input');
            if (input) {
                input.type = (input.type === "password") ? "text" : "password";
            }
        }

        // Очистка полей при загрузке страницы
        window.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.form-field-input').forEach(input => {
                input.value = '';
            });
        });
    </script>

{% endblock %}
```
### Разбор кода ```login.html```

**Этот шаблон отвечает за отображение формы входа в систему. Он расширяет базовый шаблон ```people/base.html``` и добавляет блок с формой авторизации.**


**Шаблон ```login.html``` наследуется от ```people/base.html```, что позволяет использовать стандартное оформление и элементы базового шаблона, такие как шапка, подвал и стили. Внутри тега ```{% block content %}``` определяется содержимое страницы авторизации.**

**Заголовок ```<h1 class="center-title">{{ title }}</h1>``` выводит название страницы, которое передаётся из представления. Затем создаётся контейнер ```<div class="form-container">```, содержащий форму авторизации.**

**Форма создаётся с атрибутами ```method="post"``` (чтобы передавать данные безопасно) и ```autocomplete="off"``` (чтобы браузер не подставлял сохранённые данные автоматически). Внутри формы обязательно используется ```{% csrf_token %}```, который защищает её от межсайтовых атак.**

**Цикл ```{% for f in form %}``` проходит по всем полям формы. Для каждого поля создаётся контейнер ```<div class="form-group">```, содержащий метку ```<label class="form-label" for="{{ f.id_for_label }}">```. Если поле называется ```username```, то в метке пишется ````Login````:, если ```password``` — ```Password```:, иначе используется стандартный ```{{ f.label }}```.**

**Затем идёт ```<div class="form-field password-container">```, в котором создаётся само поле ввода ```<input>```. Его тип определяется динамически: если поле называется ```password```, то оно скрыто (```type="password"```), иначе это обычное текстовое поле (```type="text"```). Атрибут ```autocomplete="new-password"``` запрещает автозаполнение браузером.**

**Если поле называется password1, рядом создаётся контейнер ```<div class="show-password-container">```, содержащий чекбокс. Этот чекбокс позволяет пользователю переключать видимость пароля.**

**Если у поля есть ошибки (```{% if f.errors %}```), они выводятся в ```<div class="form-error">```, где каждое сообщение об ошибке отображается внутри ```<p class="error-message">```.**

**В конце формы создаётся кнопка ```<button type="submit" class="submit-btn">Вход</button>```, которая отправляет введённые данные на сервер.**

**Скрипт ```<script>``` содержит две функции. Первая — ```togglePassword(checkbox)```, которая меняет тип поля ввода с ```password``` на ```text```, когда пользователь нажимает на чекбокс «Показать пароль». Вторая — обработчик события ```DOMContentLoaded```, который очищает все поля формы при загрузке страницы, чтобы при повторном посещении данные не оставались заполненными.**

***
### Подключение класса представления к маршруту ```urls.py```

**Сначала необходимо связать созданный класс представления ```LoginUser``` с маршрутом URL. Для этого в файле ```urls.py``` заменяем строку**

```
path('login/', login, name='login'),
```

**на**

```
path('login/', LoginUser.as_view(), name='login'),
```
**Это позволит Django автоматически вызывать класс представления при переходе на страницу ```/login/```.**

**Теперь можно закомментировать ранее созданную функцию ```login``` в файле ```views.py```:**

```
# # Страница для авторизации    
# def login(request):
#     return render(request, 'people/login.html', {"menu": menu, "title": "Авторизация"})
```
**После этого запускаем веб-сервер и проверяем работу приложения.**

### Ошибка 404 при успешной авторизации

**При попытке войти под существующим пользователем, например:**
```
Логин: user123123  
Пароль: art456456  
```
**происходит редирект на URL ```/accounts/profile/```, который в нашем проекте не обработан, и мы получаем ошибку ```Page Not Found 404```.**

**Это стандартное поведение Django: если явным образом не указать URL для перенаправления после успешной авторизации, он по умолчанию отправит пользователя на ```/accounts/profile/```.**

**Чтобы изменить это поведение, добавляем метод ```get_success_url()``` в ```LoginUser``` в ```views.py``` после метода ```get_context_data```:**
```
def get_success_url(self):
    return reverse_lazy('home')
```

**Теперь при успешной авторизации пользователь будет автоматически перенаправляться на главную страницу (```home```).**

**После внесения изменений проверяем:**

1. **Открываем форму авторизации**
2. **Вводим ```user123123``` и ```art456456```**
3. **Нажимаем кнопку "Вход"**
4. **Теперь нас автоматически перенаправляет на главную страницу, и в административной панели видно, что пользователь ```user123123``` успешно вошёл в систему.**

### Альтернативный способ указания страницы перенаправления

**Вместо переопределения метода ```get_success_url()``` можно задать это поведение глобально в файле ```settings.py```. Для этого добавляем в конец файла:**
```
LOGIN_REDIRECT_URL = '/'
```

**Это говорит Django, что после успешного входа пользователь должен быть перенаправлен на главную страницу (```/```).**

**Теперь, если закомментировать метод ```get_success_url()```, авторизация всё равно будет работать правильно, так как поведение переопределено на уровне конфигурации:**

```
# def get_success_url(self):
#     return reverse_lazy('home')
```

**Если вдруг возникают проблемы с входом, можно попробовать зайти в ```admin``` и поменять пароль пользователя вручную.**

## Создание формы авторизации в forms.py

**Теперь создадим отдельный класс формы, который будет представлять собой форму авторизации. В файле ```forms.py``` добавляем в конец:**

```
class LoginUserForm(AuthenticationForm):
    username = forms.CharField(label='Логин', widget=forms.TextInput(attrs={'class': 'form-input'}))
    password = forms.CharField(label='Пароль', widget=forms.PasswordInput(attrs={'class': 'form-input'}))
```
**Этот класс наследуется от ```AuthenticationForm```, который является встроенной формой Django для аутентификации. Мы расширяем его, добавляя кастомные стили через ```widget```.**

**Обязательно импортируем ```AuthenticationForm```:**

```
from django.contrib.auth.forms import AuthenticationForm
```

**Теперь в ```views.py``` можно удалить импорт ```AuthenticationForm```, так как он уже не нужен**

**В отличие от формы регистрации (```RegisterUserForm```), здесь не требуется использовать класс ``Meta``, так как мы не привязываем форму к модели ```User```. Мы явно указываем только два обязательных поля — ```username``` и ```password```, но при необходимости можно добавить другие поля, например, ```email``` или имя пользователя.**

**Теперь в ```views.py``` в классе ```LoginUser``` добавляем строку:**

```
form_class = LoginUserForm
```
**Это указывает Django использовать нашу кастомную форму для входа вместо стандартной**

## Обработка ошибок при неверном вводе

**Ранее, если пользователь вводил неправильные данные, форма просто очищала поля без объяснений. Теперь мы добавим обработку ошибок в ```login.html```.**

**Перед кнопкой "Вход" (```<button>```) добавляем следующий блок кода:**

```
{% if form.non_field_errors %}
    <div class="form-error">
        {% for error in form.non_field_errors %}
            <p class="error-message">{{ error }}</p>
        {% endfor %}
    </div>
{% endif %}
```
**Теперь, если пользователь вводит неверные данные, Django отобразит сообщение об ошибке прямо на странице, например:**

* **"Введите правильные имя пользователя и пароль."**
  
* **"Этот аккаунт не активирован."**

**Теперь улучшим нашу страницу еще больше: если пользователь уже авторизован, ему не нужно видеть ссылки «Регистрация» и «Войти». Вместо этого отобразим кнопку «Выйти» и, возможно, добавим приветствие с его именем.**

### 1. Обновление ```base.html```

**Перейдем в базовый шаблон ```base.html```, где у нас отображается главное меню:**

```
{% block mainmenu %}
    <div class="header">
        <ul id="mainmenu" class="mainmenu">
            <!-- Логотип -->
            <li class="logo"><a href="{% url "home" %}"><div class="logo"></div></a></li>
            
            {% for m in menu %}
                <li><a href="{% url m.url_name %}">{{m.title}}</a></li>
            {% endfor %}    
            <li class='last'><a href="{% url 'register' %}">Регистрация</a> | <a href='{% url 'login' %}'>Войти</a></li>
        </ul>
        <div class="clear"></div>
    </div>
{% endblock mainmenu %}
```

**Нам нужно добавить условие с пунктами «Регистрация» и «Войти»:**

**По итогу отрезок кода что выше будет выглядеть так**

```
    <!-- Блок главного меню -->
    {% block mainmenu %}
        <div class="header">
            <ul id="mainmenu" class="mainmenu">
                <!-- Логотип -->
                <li class="logo"><a href="{% url "home" %}"><div class="logo"></div></a></li>
                
                {% for m in menu %}
			        <li><a href="{% url m.url_name %}">{{m.title}}</a></li>
                {% endfor %}    
                
                {% if request.user.is_authenticated %}
                    <li class="last"> {{user.username}} | <a href="{% url 'logout' %}">Выйти</a></li>
                {% else %}
                    <li class='last'><a href="{% url 'register' %}">Регистрация</a> | <a href='{% url 'login' %}'>Войти</a></li>
                {% endif %}
            
            </ul>
            <div class="clear"></div>
        </div>
    {% endblock mainmenu %}
```

**Теперь логика следующая:**

* **Если пользователь авторизован, отображаем его имя (```user.username```) и ссылку «Выйти».**

* **Если не авторизован, показываем стандартные ссылки «Регистрация» и «Войти».**

### 2. Настроим выход пользователя

**В файле ```urls.py``` добавим маршрут для выхода. Пока что он ошибочный, так как указывает на класс `LoginUser`:**
```
path("logout/", LoginUser.as_view(), name="logout"),  # Выход пользователя (ошибка)
```

**Заменяем его на корректный маршрут, который будет обрабатывать функцию `logout_user`:**
```
path("logout/", logout_user, name="logout"),  # Выход пользователя
```

### 3. Реализуем функцию `logout_user` в `views.py`

**Добавим следующую функцию:**

```
def logout_user(request):
    logout(request)
    return redirect('login')
```

**Как это работает:**

* **Вызывается стандартная джанговская функция `logout(request)`, которая завершает сеанс пользователя.**

* **После выхода пользователя перенаправляем на страницу логина с помощью `redirect('login')`.**

**Функция `logout` уже встроена в Django, поэтому ее нужно импортировать:**

```
from django.contrib.auth import logout
```

**Теперь, когда пользователь нажимает на «Выйти», он разлогинивается и автоматически попадает на страницу авторизации.**

### 4. Автоматическая авторизация после регистрации

**Улучшим процесс регистрации: после успешной регистрации пользователь будет сразу входить в систему без необходимости повторно вводить данные.**

**Для этого в `views.py` внутри класса `RegisterUser` добавим метод `form_valid`:**

```
def form_valid(self, form):
    user = form.save()
    login(self.request, user)
    return redirect('home')
```

**Как это работает:**

* **`form.save()` — сохраняет пользователя в базе данных.**

* **`login(self.request, user)` — авторизует пользователя сразу после регистрации.**

* **`redirect('home')` — перенаправляет пользователя на главную страницу.**

**Чтобы функция `login` работала, ее тоже нужно импортировать:**

```
from django.contrib.auth import login
```

## Теперь весь функционал полностью готов:

✅ **Регистрация работает.**

✅ **После регистрации пользователь автоматически авторизуется.**

✅ **Авторизованный пользователь видит свое имя и кнопку «Выйти».**

✅ **При выходе его разлогинивает и перенаправляет на страницу входа.**

**Если при тестировании возникают ошибки с входом, можно изменить пароль пользователя через админ-панель Django.**















