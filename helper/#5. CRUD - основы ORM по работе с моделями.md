# Теперь будем учится работать с таблицей people

***Будем добавлять,выбирать, менять и удалять записи***
```
Create - создание;
Read - чтение;
Update - изменение;
Delete - удаление;
```
***В ORM Фреймворка Django мы разберем, как выполняются эти операции. Почти все проекты которые построенные на джанго используют его встроенную ORM не переходя на уровень SQL запросов. В этом нет необходимости так как этот ORM предостовляет Богатые возможности по работе с базой данных, и кроме того это обеспечивает незовисемость програмного кода от конкретной используемой СУБД. И если в будущем потребуется изменить тип базы данных, то сделать это будет предельно просто. Наконец в ORM-Django хорошо оптимизирует запросы по скорости выполнения и чистоте обращение к таблицам. Так же обеспецивает защиту от SQL-иньекции. Благодоря этому даже начинающий програмист сможет создавать грамотный код по работе с базой данных.***

***И Самое главное что нужно предстовлять это то что каждый экземпляр вот такого класса***
```
class People(models.Model):
    title = models.CharField(max_length=255)
    content = models.TextField(blank=True)
    photo = models.ImageField(upload_to="photos/%Y/%m/%d/")
    time_create = models.DateTimeField(auto_now_add=True)
    time_update = models.DateTimeField(auto_now=True)
    is_published = models.BooleanField(default=True)
```
***Предстовляет строго одну запись в таблице people_people которая создана у нас в таблице базы-данных. Приступим и посмотрим как это делается.***

**Переходим в терминал и набираем следующую команду**
```
(venv) PS D:\My Dream\virtual environment\coolsite> python manage.py shell
```
**Таким образом мы войдем консоль Django и уже в этой консоли будем работать непосредственно с этими командами ORM**
***
### *Импортируем модель*
```
>>> from people.models import People
```
**Теперь этот класс мы можем использовать.**
***
***
### *С помощью этого класса People  создадим новую запись в таблице базы данных*
```
>>> People(title="Анджелина Джоли", content="Биография Анджелины Джоли")
```
**Вызвали конструктор People и два именованых параметра title и  content и в них будут записаны те данные которые мы в них указали. Ну а почему мы не указываем другие поля которыеприсудствуют в нашей таблице ?  Дело в том что два поле time_create. time_update создаются автоматически, благодаря параметрам которые мы в них прописали. is_published тоже автоматически пропишется со значением True. А вот поле photo будет просто пустой строкой. пока что мы его прописывать не будем.**
***
**Козалось выполняя эту строчку мы должны увидеть новую запись в нашей таблице, переходим в программу, и обновим данные. В итоге ничего не видем, дело в том что модели в фреймворке Django по умолчанию являются ленивыми. Создание экземпляра класса еще не означает добавление записи в таблицу. Мы можем в разных местах создавать объекты моделей и только в последний момент запустить их на исполнение - заносить их в базу данных. Благодаря этому Django имеет возможность оптимизировать SQL запросы и излишне не нагружать СУБД.**

**Теперь укажем фреймврку сохранить созданную запись в таблице. Для этого возьмем переменную к примеру w1  и присвоем = ей то что получили в предыдущей момент _ т.е. ссылка на объект People.**
```
w1 = _
```
**А само подчеркивание это специальная переменная которая сохраняет в себе последнии действия. и теперь если мы отобразим эту переменную то она отобразит нам наш объект People.**
```
>>> w1
<People: People object (None)>
```
**Теперь помещаем эту запись в таблицу. Для этого используется метод .save(), выполняя его мы сохраняем наши данные в таблицу.**
```
>>> w1.save()
```
**И так чтобы убедится, зайдем в програму, обнавим и увидим что у нас добавилась одна запись. все в этой таблице понятно, единственное что is_published принимает значение 1 это - True**

***Теперь разберем один момент, Когда мы создали объект, он у нас выводился так - <People: People object (None)> Тут в круглых скобках у нас стоит значение (None) и так что это за None ? Тут отображается id  записи. Так как запись не была добавлена то ее значение id  принемала None. Давайте проверим теперь какой будет id  у этой значения None.***
```
>>> w1
<People: People object (1)>
```
**Теперь это id принимает значение 1, Перейдем в программу и увидем в столбце в id  значение 1. Теперь мы можем оперировать это переменной w1.**

***Проверим id***
```
>>> w1.id
1
```
***Проверяем заголовок записи***
```
>>> w1.title
'Анджелина Джоли'
```
***Дата добавления записи***
```
>>> w1.time_create
datetime.datetime(2024, 10, 10, 10, 30, 50, 502283, tzinfo=datetime.timezone.utc)
```
**Таким образом можно работать со всеми полями. Но помимо стандартных атрибутов, объекты моделей содержат еще один часто используемый атрибут, а именно .pk**
```
>>> w1.pk
1
```
**В данном случае он принисмает значение 1 - это значение совподает со значением id. Зачем это нужно ? Дело в том что поле id  имеет очень важно значение,часто по этому полю устанявливается связь между таблицами. Поэтому по соглашению Django, решили определить этот атрибут со строго определенным именем и всегда будет доступен и содержать номер текущей записи, либо значение None если оно не определено. Мы еще будем не раз обращатся к этому pk как идентификатору записи.**

**Теперь посмотрим на SQL запрос которы был выполнен для добовлени этой записи.**

### *Ипортируем модуль*
```
>>> from django.db import connection
```
**Используем его для того чтобы посмотреть какие запросы были осуществлены к нашей базе данных**
```
>>> connection.queries
INSERT INTO "people_people" ("title", "content", "photo", "time_create", "time_update", "is_published") 
VALUES ('Анджелина Джоли', 'Биография Анджелины Джоли', '\\', '2021-01-13 09:06:50.840292', '2021-01-13 09:06:50.840292', 1);

```
**Для примера содадим еще одну запись и мы сразу присвоим переменную w2**
```
>>> w2 = People(title="Энн Хэтэуэй", content="Биография Энн Хэтэуэй")
```
**Если перейдем в базу данных она там не добавлена. Поэтому прописываем снова**
```
>>> w2.save()
```
**Теперь перейдем в программу sql, там появилась новая запись теперь если посмотрим список наших SLQ-запросов то**
```
>>> connection.queries
[{'sql': 'INSERT INTO "people_people" ("title", "content", "photo", "time_create", "time_update", "is_published") VALUES (\'Анджелина Джоли\', \'Биография Анджелины Джоли\', \'\\\', \'2021-01-13 09:06:50.840292\', \'2021-01-13 09:06:50.840292\', 1)', 'time': '0.109'}, {'sql': 'INSERT INTO "people_people" ("title", "content", "photo", "time_create", "time_update", "is_published") VALUES (\'Энн Хэтэуэй\', \'Биография Энн Хэтэуэй\', \'\\\', \'2021-01-13 09:16:16.653286\', \'2021-01-13 09:16:16.653286\', 1)', 'time': '0.563'}]

```
**Или можно сделать так, можно создать екземпляр класса People без параметров, мы нашу запись не наполняем никакими конкретными данными но, сделаем это чуть позже.**
```
>>> w3 = People()
```
**И теперь тем атребутом что у ас есть title присвоем ему значение, присвое conten = значение и после этого помещаем эти данные в таблицу.**
```
>>> w3.title = "Джулия Робертс" 
>>> w3.content = "Биография Джулии Робертс"  
>>> w3.save() 
```
**Перейдем в таблицу и у нас в тадлице появилась эта запись. И как видем благодаря тому что эти запросы являются ленивыми мы можем их наполнять в разных местах так как нам надо и только после того как они будут у нас сформированы сохранить. ЭТо очень удобно.**

**Каждый класс модели,  содержит статический объект.**
```
>>> # objects
```
**В данном примере People.objects в Django — это действительно ссылка на экземпляр класса-Менеджера (Manager), который отвечает за взаимодействие с базой данных.**
```
>>> People.objects
<django.db.models.manager.Manager object at 0x000001A34C65ABD0>
```
**Это означает, что People.objects возвращает экземпляр класса Manager. Этот класс предоставляет методы для выполнения запросов к базе данных, такие как .filter(), .get(), .all() и другие. Класс Manager является своеобразным интерфейсом для работы с таблицей базы данных, которая соответствует модели People.**

**Давайте подробно разберем теперь objects еще его называют менеджером записей. У него есть несколько весьма полезных методов. Начнем с метода добавления записи а именно .create()**
```
>>> w4 = People.objects.create(title="Ума Турман", content="Биография Умы Турман") 
```
**Тут мы обращаемся к нашему классу People не создавая экземпляра класса этого класса. Затем к статическому объекту objects - к менеджеру записей. И вызывае метод create - добавлению записи. И создает тоблицу с нашими новыми данными. И отличие данного метода от предыдущего в том, что наша запись попадает сразу в таблицу базы-данных. В чем мы сейчас можем убедится если перейдем в нее и обнавим таблицу. Причем если мы пропишем**
```
>>> w4
<People: People object (4)>
```
**То данная ссылка вернет значения всех записей и мы можем обратится к заголовку**
```
>>> w4.title
'Ума Турман'
```
**Или вывести ее главный ключ pk - primary key**
```
>>> w4.pk
4
```
**Мы можем вызвать create и без присвоения значения какой либо переменной**
```
>>> People.objects.create(title="Ума Турман", content="Биография Умы Турман") 
<People: People object (4)>
```
**Так мы можем добавлять базовом варианте новые записи в нашу таблицу**

## Теперь разберем как читать данные из таблицы People

**В самом простом варианте Это выглядит так.**
```
>>> People.objects.all()
<QuerySet [<People: People object (1)>, <People: People object (2)>, <People: People object (3)>, <People: People object (4)>]>
```
**Тут мы видем все идентификаторы от единицы до 5. Но что если вместо этой непонятной информации <People: People object (1)>, Отображать заголовки наших записей. Для этого нам нужно перейти в модуль coolsite/people/models.py и внесем дополнительно данные для этого пропишем дандер метод.**
```
    def __str__(self):
        return self.title

```
**Данный дандр метод будет выводить вместо строки   ***People object (1)***  текущую запись. ***self*** - это ссылка тикущий екземпляр класса. **

**Чтобы изменения вступили в силу нам нужно перезапустить оболочку Django.**
```
>>> exit()
```
**Обратно входим**
```
(venv) PS D:\My Dream\virtual environment\coolsite> python manage.py shell
```
**Импортируе модули для работы.**
```
>>> from people.models import People
>>> from django.db import *
>>> from django.db.models import * Пока не обязательно
```
**Теперь выполним команду которая выбирает все записи из нашей таблицы.**
```
>>> People.objects.all()
<QuerySet [<People: Анджелина Джоли>, <People: Энн Хэтэуэй>, <People: Джулия Робертс>, <People: Ума Турман>]>
```
**Теперь у нас отображается более понятная инфрмация о том какие женщины у нас были выбраны. Но как нам из списка ***QuerySet*** выделять отдельные записи. Присвоем переменной данный спсок w = _**
```
>>> w = _
```
**Но так как это список то мы можем обращаться к отдельным элементам этого списка просто по индексу.**
```
>>> w[0] 
<People: Анджелина Джоли>
>>> w[1] 
<People: Энн Хэтэуэй>
>>> w[2] 
<People: Джулия Робертс>
>>> w[3] 
<People: Ума Турман>
```
**И так же если мы хотим брать отдельные поля то для этого просто добавляем поле в данном случае у нас оно title или content.**
```
>>> w[0].title
'Анджелина Джоли'
>>> w[0].content
'Биография Анджелина Джоли'
```
**Для того чтобы узнать общее количество записей**
```
>>> len(w)
4
```
**И так как список итереируемый объект то мы его можем перебрать.**
```
>>> for wi in w:
...     print(wi.title)
...
Анджелина Джоли
Энн Хэтэуэй
Джулия Робертс
Ума Турман
```
**Ну а если наша таблица будет состоять не из 5 а из тысяч или из миллиона записей, все они конечно будут возвращатся методом all() ***"В консоль она выведит всего 20 записей из за ограничения, но на самом деле она возвращает все записи из таблици просто мы етого не увмдем в консоли."***. И это бывает не очень хорошо с точки зрения расходов на память и ресурсов процесора. Обычно в программе нам требуется всего несколько записей, Выбранных по определенному критерию. Поэтому вместо этого метода ***all()*** Следует использовать другой метод - filter().**
```
>>> People.objects.filter(title="Энн Хэтэуэй") 
<QuerySet [<People: Энн Хэтэуэй>]>
```
**И тут мы выбираем все записи у которых такой заголовок. В данном случае будет выбрана одна запись.**

**Теперь дадим запрос к pk**
```
>>> People.objects.filter(pk=2)                
<QuerySet [<People: Энн Хэтэуэй>]>
```

**И так как нам выполнить такую операцию People.objects.filter(pk > 2) т.е. взять все ключи которые больше двух или равно двум. Для этого в Django к базовым атрибутам которые там есть, pk, title, content, и т.д. можно можно следдовать такому правилу.**

* ### <имя атрибута>__gte - сравнение больше или равно (>=);
* ### <имя атрибута>__lte - сравнение меньше или равно (<=).

**теперь на основе данной шпаргалки выберем все записи которые больше или равно двум. Переходим в кансоль django-shell и выполняем эту команду.**
```
>>> People.objects.filter(pk__gte=2) 
<QuerySet [<People: Энн Хэтэуэй>, <People: Джулия Робертс>, <People: Ума Турман>]>
```
**Теперь разберем метод противоположный filter а именно exclude. Он выбирает все записи которые не соответствуют критерию, например.**
```
>>> People.objects.exclude(pk__gte=3) 
<QuerySet [<People: Анджелина Джоли>, <People: Энн Хэтэуэй>]>
```
**И так эти методы filter и exclude позволяют выбирать записи по определеннуму условию. Ну что если нам нужно выбрать только одну запись? Обычно используя ее идентификационный номер ID. Конечно мы можем использовать метод filter и прописать все в таком виде...**
```
>>> People.objects.filter(pk=2) 
<QuerySet [<People: Энн Хэтэуэй>]>
```
**Но согласно Django на уровне ORM В данном случае, когда нам нужно выбрать строго определенную запись по какому то определенному критерию лучше использовать метод gte. Если мы у него укажим точно такое же условие что и в предыдущем случае, конечно, мы увидем такой же результат что и прежде.**
```
>>> People.objects.get(pk=2) 
<People: Энн Хэтэуэй>
```
**Так в чем отличие между filter и gte ?**

**А отличчие в том что если по условию у нас в последнем запросе в скобках окажется больше чем одна запись...**
```
>>> People.objects.get(pk__gte=2) 
Traceback (most recent call last):
  File "<console>", line 1, in <module>
  File "D:\My Dream\virtual environment\venv\Lib\site-packages\django\db\models\manager.py", line 87, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\My Dream\virtual environment\venv\Lib\site-packages\django\db\models\query.py", line 652, in get
    raise self.model.MultipleObjectsReturned(
people.models.People.MultipleObjectsReturned: get() returned more than one People -- it returned 3!
```
**То у нас сгенерируется исключение. Или такой вариант, если мы укажим условие при котором не будет выбрана ни одна запись то, тоже будет сгенерированна исключение.**
```
>>> People.objects.get(pk=20)  
Traceback (most recent call last):
  File "<console>", line 1, in <module>
  File "D:\My Dream\virtual environment\venv\Lib\site-packages\django\db\models\manager.py", line 87, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\My Dream\virtual environment\venv\Lib\site-packages\django\db\models\query.py", line 649, in get
    raise self.model.DoesNotExist(
people.models.People.DoesNotExist: People matching query does not exist.
```
**Во всех этих случаях метод  ***filter*** будет возврощать либо несколько записей либбо пустой список. А метод ***get*** генерирует исключение. Используя метод ***get*** мы уверенны что была получина только одна запись и в таблице по указанному условию других записей нет. Часто это бывает очень важно при авторизации пользователя. Мы должны найти одну уникальную запись связанную именно с ним и никакую другую. В этом случае метод ***get*** просто незаменим. Если при выборке записи нам нужно добавить порядок сортировки по какому-либо полю то, для этого можно воспользоватся методом ***order_by*** и указать поле по которому происходит сортировка, в нашем случае это ('title').**
```
>>> People.objects.filter(pk__lte=4).order_by('title') 
<QuerySet [<People: Анджелина Джоли>, <People: Джулия Робертс>, <People: Ума Турман>, <People: Энн Хэтэуэй>]>
```
**Мы выбрали все ключи у которых ID меньше или равен четырем и отсортировали по полю ***title***. А если мы перейдем в таблицу базы-данных то увидим что в таблице записи идут в другом порядке. Наш вызов отсортирован по алфавиту**

**Конечно же можно сделать проще, можно выбрать все записи отсортировать по заголовку. Добавим новую запись в таблицу чтобы проследить разницу между вызовом всех записей и выборкой из четырех. В моем случае добавлена была Кира Найтли.**
```
>>> People.objects.order_by("title") 
<QuerySet [<People: Анджелина Джоли>, <People: Джулия Робертс>, <People: Кира Найтли>, <People: Ума Турман>, <People: Энн Хэтэуэй>]>
```
**Так же мы можем вместо title использовать время изменения записи и здесь мы для примера поставим минус - он означает обратный порядок сортировки.**
```
>>> People.objects.order_by("-time_update") 
<QuerySet [<People: Кира Найтли>, <People: Ума Турман>, <People: Джулия Робертс>, <People: Энн Хэтэуэй>, <People: Анджелина Джоли>]>
```
**Ну а если минус уберем то порядок соответсвнно поменяется.**

**А теперь посмотрим как менять существующие записи в таблице. В самом простом случае для изменения какой либо записи ее можно сначало прочитать из базы данных**
```
>>> w1 = People.objects.get(pk=2)
```
**Ну а теперь заменим ее.**
```
>>> w1.title = 'Марго Робби' 
>>> w1.content = "Биография Марго Робби" 
``` 
**А затем сохраняем объект**
```
>>> w1.save()
```
**И теперь вместо второй записи у нас записанна Марго Робби.**

**И теперь удаление записи.**
```
>>> w3 = People.objects.filter(pk__gte=5) 
>>> w3
<QuerySet [<People: Кира Найтли>]>
>>> w3.delete()
(1, {'people.People': 1})
```










