# Продолжоаем тему о Шаблонах

**Теперь сделаем следующие важные шаг. ***Научимся подключать к шаблонам статические файлы.*** К примеру оформление CSS и JavaScript. Тут есть свои тонкости как помним, наше приложение может работать в двух режимах, "*в режиме отладки на тестовом веб-сервере*", "*И в режиме эксплуатации на реальном веб-сервере*".**
```
coolsite/
├── coolsite/
│   └── static/  # нестандартный путь для статических файлов
├── women/
│   ├── static/  # стандартная папка для приложения women
│   └── templates/
└── static/  # общая папка для статических файлов веб-сервера
```
1. *coolsite/static/ — нестандартный путь для хранения статических файлов. Обычно используется в случае, если вы указали его в STATICFILES_DIRS.*

2. *women/static/ — стандартная директория для статических файлов внутри приложения women. Django автоматически ищет файлы в этой папке, если приложение добавлено в INSTALLED_APPS.*

3. *static/ — общая папка для статических файлов, которая обычно указывается в продакшн-окружении с помощью команды collectstatic. Файлы собираются сюда из всех приложений и директорий, указанных в STATICFILES_DIRS.*

**Так как появляется общая папка со всеми необходимыми статическими файлами ?**

**Для этого при подготовки проекта к эксплуфтации выполняется специальная команда, ```python manage.py collectstatic``` и все статические каталоги пробигаются, из них берутся все файлы которые в них находятся, и перемещаются в "Общию папку" и потом уже из этой общей папки будут братся все наши статические файлы. Для того чтобы корректно работал функционал управления статическими файлами в Django при подготовке проекта к эксплуатации, необходимо определить три важные константы в файле настроек ```settings.py.``` Эти константы позволяют Django правильно собирать и обслуживать статические файлы, особенно на продакшн-сервере.**

### Три ключевые константы:
1. ***STATIC_URL:***

* ***Эта константа задаёт URL, по которому будут доступны статические файлы на сайте.***
```
STATIC_URL = '/static/'
```
2. ***STATICFILES_DIRS (опционально):***
* ***Указывает дополнительные пути (каталоги) для поиска статических файлов в процессе разработки. Используется, если у вас есть статические файлы, которые не относятся к конкретному приложению, но нужны для всего проекта.***
```
STATICFILES_DIRS = [
    BASE_DIR / 'static',  # Путь к общей директории статических файлов в проекте
]
```
3. ***STATIC_ROOT:***
* ***Это директория, в которую будут собраны все статические файлы (из приложений и других директорий), когда вы выполните команду collectstatic. Эта директория будет использоваться веб-сервером (например, Nginx) для обслуживания статических файлов на продакшн-сервере.***
```
STATIC_ROOT = BASE_DIR / 'staticfiles'  # Общая директория для статических файлов после collectstatic
```
**И так первым делом определим эти три переменные в нашем проекте. Для этого переходим в проект конфигураций-settings.py и в самом низу пропишем все эти константы.**
```
# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = '/static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Настройка пути к директории для загрузки медиа-файлов
MEDIA_ROOT = os.path.join(BASE_DIR, "static")
MEDIA_ROOT = os.path.join(BASE_DIR, "media") # Директория media будет создана в корне проекта
STATICFILES_DIRS = [] # Здесь будут хранится список нестандартных путей

# URL для доступа к медиа-файлам через веб
MEDIA_URL = "/media/" 
```
**Теперь создадим папку ```static``` в нашем приложении ```people```. И так же как для наших шаблонов, дополнительно в этом каталоге создадим подкаталог ```people```, дожно получится так - coolsite/people/static/people, это нужно чтобы не возникало конфликта имен. В действительности джанго найдет просто подходящий файл и на нем остановится. И чтобы файл это был тем что нам нужен, как раз используется подкоталок, который играет роль некоторого пространство имен. И уже тут, в этом подкаталоге мы создадим еще каталоги ```css``` и  ```js``` для файлов JavaScript и еще один подкоталог для хранения картинок ```images```. "Это три подкоталога которые мы можем подключать в статических шаблонах.**

**В подкталоге ```css``` мы разместим файл ```styles.css``` оформление для наших шаблонов. И сюда разместим стили заготовленные для наших шаблонов нужно просто скопировать их из статических файлов из текущего проекта. И соответственно мы скопируем к себе из проекта папку images. Все теперь мы можем использовать эти внешние файлы в шаблонах нашего приложеня**

**Открываем шаблон ```base.html``` и в начале этого шаблона пропишем тег load.**
```
{% load static %}
```
**Тег load, он загружает тег static, через которые мы будем подключать внешние файлы. Тег {% load static %} в Django загружает шаблонный тег static, который используется для ссылки на статические файлы, такие как CSS, JavaScript или изображения. Этот тег позволяет динамически генерировать правильные URL для статических файлов, с учётом настроек вашего проекта.**

**В разделе ```<head>```, под заголовком ```<title>{{title}}</title>``` Подключаем CSS файл, который находится по пути 'static/women/css/styles.css'. Используем тег static для динамической генерации корректного URL.**
```
<link type="text/css" href="{% static 'women/css/styles.css' %}" rel="stylesheet" />
Чтобы не перегружать материал мы скопировали файлы about.html, base,html, index,html
```
**Чтобы не перегружать материал мы скопировали файлы about.html, base,html, index,html и замениил из у себя в проекте. Так же перебрали css стили для передачи более мягких танов (Серый, голубой, зеленый). Так же пропишем и информацию в базе данных о наших знаменитостях в content-биография. Как все скапируем и заменим наши файлы css и все 3 шаблона то можено перейти на нашу страничку и посмотреть как выглядит она теперь.**

## ***[BOOTSTRAP](https://getbootstrap.com/)***
**Если мы перейдем по ссылки то попадем на сайт через который мы можем брать различные оформления для нашего сайта. Мы Намеренно им пока не пользуемся.**

### *Вывод контента с фильтрацией и ограничением*
**На нашем сайте можно выводить контент, настроив его предварительно. В шаблоне index.html каждая строка расписана. Нам важен следующий фрагмент кода:**
```
{{ p.content|linebreaks|truncatewords:50 }}

```
*Описание*

1. **```p.content``` — это переменная, содержащая текст контента поста.** 

2. **```linebreaks``` — фильтр, который преобразует переносы строк в текстовом контенте в теги ```<p>``` (абзац) и ```<br>``` (перенос строки). Это помогает правильно отображать текст с абзацами.**

3. **```truncatewords:50``` — фильтр, который ограничивает вывод текста до 50 слов. Если контент длиннее, он будет обрезан до указанного количества слов, что позволяет контролировать объём выводимого текста.**

***форматирует строки таким образом, что каждая новая строка в тексте будет обёрнута в тег ```<p>```, а сам текст будет ограничен 50 словами. Это полезно, когда нужно показать сокращённую версию поста на странице с предварительным просмотром.***

## Экранирование тегов и autoescape в Django

**Экранирование в веб-разработке — это процесс обработки специального символа так, чтобы он не интерпретировался как HTML-код. Экранирование предотвращает выполнение вредоносного кода, вставленного в текст (например, через XSS-атаки).**

***Экранирование тегов***

**Когда вы выводите данные в HTML с помощью Django-шаблонов, если включено автоэкранирование, специальные символы будут заменены на их безопасные эквиваленты. Вот основные примеры:**
```
Символ	| Экранированный вид
<	    | &lt;
>	    | &gt;
&	    | &amp;
"	    | &quot;
'	    | &#x27;
```
**Экранирование защищает от инъекций кода, когда пользователи могут вводить произвольные HTML или JavaScript в поля на сайте.**

```autoescape on``` **и** ```autoescape off```

**В Django шаблонах есть возможность включить или выключить автоматическое экранирование с помощью ```{% autoescape %}``` блока.**

* **```{% autoescape on %}``` — включение автоматического экранирования. Это защищает выводимые данные от выполнения вредоносного HTML или JavaScript. Этот режим включён по умолчанию.**

* **```{% autoescape off %}``` — выключение автоэкранирования. Используется, если вы точно знаете, что выводимый контент безопасен, или вам нужно, чтобы HTML-теги интерпретировались браузером как валидные теги (например, когда вы хотите вывести HTML-код без изменений).**

***Пример использования***

**У нас есть строка, которая содержит HTML-теги, и мы хотим вывести её в шаблоне index.html.**

```
<!-- Включаем автоэкранирование HTML, чтобы защититься от инъекций, автоматически преобразуя специальные символы в HTML-сущности. -->

{% autoescape on %}
	{{p.content|linebreaks|truncatewords:50}}
{% endautoescape %}
```

**Если в post.content есть HTML-теги, например, ```<p>Привет</p>```, они будут экранированы и выведены как текст:**

```
&lt;p&gt;Привет&lt;/p&gt;

```

**С выключенным автоэкранированием:**


```
<!-- В этом случае HTML-теги будут интерпретироваться браузером: -->

{% autoescape off %}
	{{p.content|linebreaks|truncatewords:50}}
{% endautoescape %}
```
**вывод**
```
<p>Привет</p>

```
### Рекомендации
* **Используйте автоэкранирование по умолчанию — это помогает избежать уязвимостей, особенно XSS-атак.**
* **Отключайте автоэкранирование только при необходимости, когда вы уверены в безопасности выводимого HTML-кода.**

## Пример XSS-атаки
**Без экранирования, злоумышленник может вставить вредоносный код, который будет выполнен браузером:**
```
<script>alert('XSS!');</script>
```
## Если автоэкранирование включено, этот код будет преобразован в текст и не выполнится.








