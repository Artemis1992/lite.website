## Использование тега URL для формирование маршрутов к URL-схемам

**На данный момент поняли как создавать шаблоны и прописывать в них различные теги ```{% имя тега %}```, ```{{ Имя_переменной }}```, ```{{value|имя_файла}}```. Курс по данной тематики [Jinja2 шаблонизатор](https://youtu.be/cFJqMXxVNsI?si=HIb0BefdjzhvOCM9)**

**Следующим важным шагом это научится правильно указывать URL-адреса**

**Мы во всех ссылках прописывали такую заглушку символ "#". Пришло время сформировать полноценные ссылки на страницы. Для этого в Django используют специальный тег URL: ```{% url'<URL-адрес или имя маршрута>'[параметры ссылки]%}```, За ним идет адрес или имя маршрута, а также необязательный параметр ссылки. То есть, если у ссылки есть какие-то параметры, мы можем их указать в [параметры ссылки]**

**Сейчас пропишем с помощью тега URl маршрут к главнй странице. Для этого переходим в проект наш и откроем файл шаблона ```base.html``` и видем что ссылка в нашем шаблоне прописана так "#"**
```
        <div class="header">
            <ul id="mainmenu" class="mainmenu">
                <!-- Логотип -->
    ---->       <li class="logo"><a href="#"><div class="logo"></div></a></li>
                
                <!-- Цикл по элементам меню -->
```
**Если мы хотим указать тут "#" ссылку на главную страницу, мы можем поступить разными способами для примера запишем вместо шарпа просто слеш "/"**
```
    ---->       <li class="logo"><a href="/"><div class="logo"></div></a></li>
```
**перейдем на сайт и нажмем на эмблему сайта и действительно мы перешли на главную страницу**

**Однако прописывать ссылки таким образом не лучший путь, потому что URL главной страницы не обязательно должен совподать с доменным именем. Если вдруг он изменится то везде в шаблонах нужно вносить соответсующие изменения. Гораздо практичнее и чаще всего так делают, используют имена маршрутов.**

**Если мы откроем файл ```urls.py```, то увидим имена двух маршрутов ```home```, ```about```.**
```
urlpatterns = [
    path('', index, name='home'),
    path('about/', about, name='about'),

]
```
**Сейчас нас интересует маршрут ```home```, Сейчас воспользуемся этим именем ```name='home'``` для того чтобы прописать этот маршрут ```('',``` на главную страницу, но прописывать будем в шаблоне ```base.html```, там где у нас прописан был маршрут так "/". Как раз для этого мы воспользуемся тегом url ```{% url "home" %}```**
```
        <div class="header">
            <ul id="mainmenu" class="mainmenu">
                <!-- Логотип -->
                <li class="logo"><a href="{% url "home" %}"><div class="logo"></div></a></li>
                
                <!-- Цикл по элементам меню -->
```
**Теперь переходим на главную страницу и жмем на эмблему сайта и действительно наша ссылка формируется на главную страницу.  Но если по каким то причинам главная страница в маршрутах в файле ```urls.py``` изменится допустим так   ```path('home/', index, name='home')```, переходиим в браузер и обновляем нашу страницу и соответсвенно увидем Page not found. Теперь пропишем ссылку в адресной страке http://127.0.0.1:8000/home/ и теперь нажме на эмблему сайта и действительно будем переходить на главную страницу. Как видем такой подход с использованием имен гораздо удобне. И если что то изменится в маршрутах то в шаблоне ```base.html```**
```
    <!-- Блок главного меню -->
    {% block mainmenu %}
        <div class="header">
            <ul id="mainmenu" class="mainmenu">
                <!-- Логотип -->
                <li class="logo"><a href="{% url "home" %}"><div class="logo"></div></a></li>
                

```
**Ничего менять не надо. Все изменения пременятся автоматически. Но пока что мы вернем все как и было в файле ```urls.py``` в строке сделаем так```path('', index, name='home')```**

## *Создание страниц и ссылок для пунктов меню хедера*
**Для этого в проекте в файле ```views.py``` там где формируется главное меню мы его определим другим списком - Список из словарей**
```
menu = [{"title": "О сайте", "url_name": "about"},
        {"title": "Добавить статью", "url_name": "add_page"},
        {"title": "Обратная связь", "url_name": "contact"},
        {"title": "Войти", "url_name": "login"},
]
```
**Этот список содержит несколько словарей, каждый из которых представляет собой пункт меню для веб-сайта. Каждый словарь имеет два ключа:**

1. **```title``` — название пункта меню, которое будет отображаться на сайте. Это заголовок ссылки, видимый пользователям.**

2. **```url_name``` — имя маршрута (URL), который связан с соответствующим пунктом меню. Это путь или имя маршрута в приложении, куда ведет ссылка.**

**Но пока что у нас нет маршрутов таких в файле ```urls.p```. Так как есть у нас ```about``` маршрут, добавим к нему еще три.**
```
urlpatterns = [
    path('', index, name='home'),  # Главная страница
    path('about/', about, name='about'),  # Страница "О сайте"
    path('addpage/', addpage, name='add_page'),  # Добавление статьи
    path('contact/', contact, name='contact'),  # Обратная связь
    path('login/', login, name='login')  # Страница входа
]
```
**Теперь нам нужно прописать 3 функции предстовления. Мы их сделаем пока просто в виде функций заглушек. Перейдем в файл ```views.py```, и вместо функций этих что ниже, пропишем другие.**
```
def categories(request, catid):
    if(request.GET):
        print(request.GET)  # Выводим параметры в терминал
    return HttpResponse(f"<h1>Статьи по категориям</h1><p>{catid}</p>")

def archive(request, year):
    # Если год больше 2024, выполняем редирект на главную страницу
    if int(year) > 2024:
        return redirect('home', permanent=True) # Редирект
    # Возвращаем HttpResponse с заголовком и значением года
    return HttpResponse(f"<h1>Архив по годам</h1><p>{year}</p>")
```
**Запишем следующие функции**
```
def addpage(request):
    return HttpResponse("Добавление статьи")

def contact(request):
    return HttpResponse("Обратная сязь")

def login(request):
    return HttpResponse("Авторизация")
```
**Теперь все функции из файла из ```views.py```, определены в фале ```urls.py```. Так же видоизменим функцию ```index```. Мы возвращаем в нашу функцию index  множество разных параметров, это не очень хорошо выглядит визуально. Потому что нам нужно делать скроллинг делать и смотреть что там написанно у нас за пределами экрана. Поэтому в таких случаях поступают следующим образом - создают специальный словарь с любым названием, главное что это словарь. И всловаре у нас перечисленны все пораметры которые мы тут передаем. А всамой функции рендер вместо вот списка словоря, Мы указываем специальный именнованный параметр context и ему присваеваем ссылку на словарь context и получается у нас так context=context**
```
def index(request):
    posts = People.objects.all()
    context = {
        'posts': posts,
        'menu': menu,
        'title': 'Главная страница',
    }
    return render(request, 'people/index.html', context=context)
```
**Теперь визуально гораздо лучше воспринисается то что тут написанно.**

**Теперь нам осталось это видоизмененное меню прописать в ```base.html``` в блоке где отображается главное меню.**
```
    <!-- Блок главного меню -->
    {% block mainmenu %}
        <div class="header">
            <ul id="mainmenu" class="mainmenu">
                <!-- Логотип -->
                <li class="logo"><a href="{% url "home" %}"><div class="logo"></div></a></li>
                
                <!-- Цикл по элементам меню -->
                {% for m in menu %}
                    {% if not forloop.last %}
                        <li><a href="#">{{m.title}}</a></li>
                    {% else %}
                        <li class="last"><a href="#">{{m.title}}</a></li>
                    {% endif %}
                {% endfor %}

```
**И нам осталось прописать эти маршруты "#" и это сделаем с помощью того же тега url ```{% url m.url_name %}```**

* Пример
```
...
                    {% else %}
                        <li class="last"><a href="#">{{m.title}}</a></li>
                    {% endif %}
...
```
**Имя маршрута мы возьмем из коллекции меню, которая определена в файле ```views.py```.
У нас ```m``` — это коллекция, содержащая словари со списком маршрутов.
На каждой итерации цикла мы берем значение ключа ```url_name``` из текущего словаря.**

**Соответственно, значения ```url_name``` могут быть такими, как:
```about```, ```add_page```, ```contact```, ```login``` и другие..**
```
menu = [{"title": "О сайте", "url_name": "about"},
        {"title": "Добавить статью", "url_name": "add_page"},
        {"title": "Обратная связь", "url_name": "contact"},
        {"title": "Войти", "url_name": "login"},
]
```
**Все эти значения будут использоваться в нашем шаблоне ```base.html``` через тег ```m.url_name```.**

**Они будут автоматически подставляться в соответствующие ссылки.**

**Затем это имя маршрута (```url_name```) будет браться из файла ```urls.py```, где указана наша коллекция маршрутов, и подставляться вместо имени конкретный URL-адрес.**
```
urlpatterns = [
    path('', index, name='home'),  # Главная страница
    path('about/', about, name='about'),  # Страница "О сайте"
    path('addpage/', addpage, name='add_page'),  # Добавление статьи
    path('contact/', contact, name='contact'),  # Обратная связь
    path('login/', login, name='login')  # Авторизация
]
```
**И тоже самое сделаем и тут**
```
                <!-- Цикл по элементам меню -->
                {% for m in menu %}
                    {% if not forloop.last %}
                        <li><a href="{% url m.url_name %}">{{m.title}}</a></li>
                    {% else %}
```
**ТАким образом мы прописали маршруты для нашего главного меню**

**ТЕперь можно перейти на нашу страницу и проверим как работает наше меню. теперь когда запускаем разделы у нас запускаются соответсвующие маршруты.**

**```О сайте```  - ```about```**

**```Добавить статью``` - ```add_page```**

**```Обратная связь``` - ```contact```**

**```Авторизация``` - ```login```**

**Осталось прописать ссылки у наших статей. И где прочитать пост у нас тоже  стоят заглушки. На них тоже надо сформировать полнценные ссылки.**

**Открываем файл ```urls.py``` тут пропишем еще один маршрут.**
```
path('post/<int:post_id>/', show_post, name='post'), #Посты
```
**Теперь наши посты будут открываться по маршруту ```post/```, Дальше указываться идентификатор этого маршрута ```<int:post_id>/```, Ну а имя марщрута будет называтся ```=post```**

***Обычно в реальных проектах, вместо ```<int:post_id>/```, используется slug ```'post/<slug:slug>/'```,***

## Зачем нужен slug:
1. ***Читаемые URL: Slug делает URL понятным для пользователей и поисковых систем. Например, вместо example.com/post/123 вы получаете example.com/post/my-first-post.***

2. ***SEO: URL с ключевыми словами (как в slug) лучше индексируются поисковыми системами.***

3. ***Идентификатор записи: Slug можно использовать как уникальный идентификатор вместо числового id.***

**Теперь нам нужно определить нашу функцию ```show_post```, в файле ```views.py```,**

```
def show_post(request, post_id):
    return HttpResponse(f"Отображение статьи с id = {post_id}")
```
**И осталось в шаблоне ```index.html```, прописать правильно ссылки ```"#"```. Тут есть два распространенных варианта как это сделать**

# *Способ 1*
1. **Динамическая ссылка с использованием тега url:**
```
"{% url 'post' p.pk %}"
```
**Здесь мы используем тег ```url``` для создания динамической ссылки.**

* **```post``` — имя маршрута, определённого в файле urls.py.**
* **```p.pk``` — идентификатор записи.**

**Переменная ```p``` — это экземпляр модели ```People```, передаваемый в шаблон. Мы получаем её в результате цикла:**
```
{% for p in posts %}
    <a href="{% url 'post' p.pk %}">{{ p.name }}</a>
{% endfor %}
```
2. *Как это работает:*

    **Переменная ```p``` передается из функции ```index``` в ```views.py```, где мы перебираем записи из базы данных. У каждого экземпляра класса ```People``` есть атрибут ```pk``` (primary key), который Django автоматически использует как идентификатор записи.**

3. *Как формируется URL:*

    **В файле urls.py маршрут для post выглядит так:**
    ```
    from django.urls import path
    from . import views

    urlpatterns = [
        ...
        path('post/<int:post_id>/', views.show_post, name='post'),
    ]
    ```
    * **```<int:post_id>``` — динамическая часть URL. Django автоматически подставляет сюда значение ```p.pk``` из тега ```url``` в шаблоне.**
    
    * **```views.show_post``` — обработчик, который будет вызван при переходе по сгенерированной ссылке.**

4. *Пример результата:*

    **Если в базе данных есть запись с pk=1, то сгенерированный адрес будет выглядеть так:**
    ```
    http://127.0.0.1:8000/post/1/

    http://127.0.0.1:8000/post/2/
    ```
    **Если мы откроем базу данных и посмотрим записи, например, Анджелина Джоли имеет ```pk=1```, то при переходе по адресу ```http://127.0.0.1:8000/post/1/``` отобразится информация о ней.**

# *Способ 2*

**Динамические ссылки, связанные с конкретными записями в базе данных, формируются аналогично. Однако в первом способе есть один недостаток: если формат адреса ```post``` изменится (например, в файле ```urls.py``` мы будем выводить посты не по ```id``` записи, а по ```slug```), то в файле ```index.html``` нам также придется изменить параметр. Вместо ```pk``` нужно будет использовать ```slug```.**

*Пример:*
```
{% url 'post' p.slug %}
```
***Это неудобно, так как динамические адреса могут формироваться в разных местах и шаблонах. Если где-то забыть внести изменения, сайт будет работать некорректно.***

### Формирование динамических адресов через метод модели
**Чтобы избежать этой проблемы, мы можем создать метод в модели, например:**
```
from django.urls import reverse

class People(models.Model):
    # Пример полей модели
    name = models.CharField(max_length=100)
    slug = models.SlugField(unique=True)
    # Другие поля...

    def get_absolute_url(self):
        return reverse("post", kwargs={"post_id": self.pk})
```
*Объяснение:*

* **```self``` — ссылка на экземпляр текущего объекта (```People```).**
* **```self.pk``` — идентификатор записи, который используется для формирования маршрута.**
* **```reverse``` — функция Django, которая формирует URL на основе имени маршрута (```post```) и переданных параметров (```post_id```).**

*Теперь можно использовать этот метод в шаблоне:*
```
{{ p.get_absolute_url }}
```
**Это удобнее, чем прописывать ссылки вручную через тег ```{% url %}```, так как адрес формируется автоматически.**
***
### Изменение маршрута в ```urls.py```
**Если мы решим использовать ```slug``` вместо ```id```, то в файле ```urls.py``` нужно будет изменить маршрут:**
```
from django.urls import path
from . import views

urlpatterns = [
    ...
    path('post/<slug:post_slug>/', views.show_post, name='post'),
]
```
**В методе модели это также нужно учесть:**
```
def get_absolute_url(self):
    return reverse("post", kwargs={"post_slug": self.slug})
```
**Теперь шаблон ```index.html``` останется неизменным, а изменения касаются только модели и маршрута.**
***
### Использование в шаблонах

1.   ### Старый способ:
        ```
        {% url 'post' p.pk %}
        ```
2. ### Новый, предпочтительный способ:
        ```
        {{ p.get_absolute_url }}
        ```
### Пример результата
**Если у нас есть такие записи в базе данных:**
```
ID	Имя	             |   Slug
1	Анджелина Джоли	 |   angelina-jolie
2	Брэд Питт	     |   brad-pitt
```
*То ссылки на посты будут выглядеть так:*
```
http://127.0.0.1:8000/post/angelina-jolie/

http://127.0.0.1:8000/post/brad-pitt/
```
**Теперь Django автоматически формирует ссылки, используя метод ```get_absolute_url```, а изменения в маршрутах потребуют лишь редактирования модели, а не шаблонов.**
***
### Дополнительное преимущество метода ```get_absolute_url```
**Согласно конвенциям Django, этот метод используется в стандартных модулях, например, в админ-панели. Если он определен в модели, админка будет автоматически обращаться к нему для построения ссылок на каждую запись. В дальнейшем вы увидите, как это работает.**







