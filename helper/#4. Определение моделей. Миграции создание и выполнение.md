***В Django используется архитектурный шаблон под названием MTV (Model-Template-View). Этот паттерн похож на известный MVC (Model-View-Controller), но имеет некоторые отличия в терминах. Рассмотрим каждую часть MTV:***

### ***1. Model (Модель):***

* **Отвечает за взаимодействие с базой данных. Модели в Django определяют структуру данных (таблицы) и способы взаимодействия с ними. Это объектно-реляционное отображение (ORM), позволяющее работать с базой данных на уровне Python объектов.**

* Пример модели:
  
    ```
    from django.db import models

    class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    pub_date = models.DateTimeField('date published')
    ```

### ***2. Template (Шаблон):***

* **Отвечает за представление данных пользователю. Шаблоны содержат HTML и позволяют встраивать данные, предоставляемые представлениями. Это аналог вида (View) в MVC.**

* Пример шаблона:
    ```
    <h1>{{ article.title }}</h1>
    <p>{{ article.content }}</p>
    ```

### ***3. View (Представление):***

* **Отвечает за логику обработки запроса и передачу данных в шаблон. Представления получают запросы от пользователя, обрабатывают их, взаимодействуют с моделями и отправляют результаты обратно через шаблоны.**

* **Пример представления:**
    ```
    from django.shortcuts import render
    from .models import Article

    def article_detail(request, article_id):
    article = Article.objects.get(pk=article_id)
    return render(request, 'article_detail.html', {'article': article})

    ```

### ***Сравнение MTV с MVC:***

* **В Django View — это логика обработки запросов (в MVC это контроллер).**
  
* **Template выполняет роль представления (View в MVC), где отображаются данные.**

* **Model остается тем же и представляет собой слой взаимодействия с базой данных.**

***Шаблон MTV помогает разделить логику, данные и представление, что делает код более структурированным и поддерживаемым.***

---

***И так в этом конспекте коснемся аспекта как уже поняли - Паттерна MTV по которому построен фреймворк джанго-модели.Как до этого говорили - модель отвечает за хранение и оперирование данными сайта. Часто для этого используются стандартные системы управления баз-данных, например***

### SQLite, MySQL, PostgreSQL, Oracle

***Они самые папулярные. Причем разработчик сайта на перед может и не знать с какой именно СУБД будет работать его WSGI приложение и может быть так что выбор может пасть на другой тип базы данных. Как в этом случае можно построить универсальную программу не привязанную к конкретной СУБД***.

***Для этого в джанго встроен мехонизм взаимодействияс таблицами баз данных Через объекты класса языка Python, посреддством технологии ORM.***
***Т.е. WSGI-приложение через API-интерфейс, ORM-Django может взаимодействовать с любым типом баз-данных. И при этом прораммный код на уровне  WSGI-приложения будет оставатся универсальным вне зависимости от выбранной систем управления баз данныхю В этом одно из преимуществ технологии ORM. Причем при работе с Django разработчику ненужно беспокоится о подключении к базе-данных и ее закрытию Когда пользователь покидает сайтю. Фреймворк такие действия берет на себя. Все что нам остается это, через модель взаимодействия(Чероез  API) и команды интерфейса, записывать и считывать данные из этих баз-данных***

### [Ссылка на SQLite](https://download.sqlitebrowser.org/DB.Browser.for.SQLite-v3.13.0-win64.msi)

***После переходим в программу. жмем в ней файл/открыть базу данных. Далее переходим в каталог проекта и находим файл с названием db.sqlite3 нашимаем открыть, после нажимаем ok. И она должна отображатся в окошки слево. Пока что в ней нет ни одной таблицы. Для этого содадим первый клас - модель которая будет описывать people(люди) и структура данной таблицы будет следующая.***

```
id: INTEGER PRIMARY KEY
title: VARCHAR
content: TEXT
photo: IMAGE
time_create: DATETIME
time_update: DATETIME
is_published: BOOLEAN
```
***Теперь определяем класс вот этой модели, перейдем в проект в файл people/models.py тут мы создаем таблицу people которая будет содержать информацию об известных людях. Класс будет следующий.***

```
class People(models.Model):
    title = models.CharField(max_length=255)
    content = models.TextField(blank=True)
    photo = models.ImageField(upload_to="photos/%Y/%m/%d/")
    time_create = models.DateTimeField(auto_now_add=True)
    time_update = models.DateTimeField(auto_now=True)
    is_published = models.BooleanField(default=True)
```
***Класс мы можем называть как захотим. И наследоватся он будет от базового класса Model. Это тбазовый класс содержит все необходимое для того чтобы мы могли создавать собственные классы моделей***

***Далее, в этом классе не прописанны поле id. Вот это поле которое у нас туту фигурирует*** 
```
id: INTEGER PRIMARY KEY
title: VARCHAR
content: TEXT
photo: IMAGE
time_create: DATETIME
time_update: DATETIME
is_published: BOOLEAN
```
***Дело в том что это id  прописано уже в базовом классе Model, Поэтому нам повторять его нет необходимовсти. ***

**Этот класс People — это Django модель, которая описывает сущность для хранения данных о людях в базе данных. Каждый объект этого класса будет соответствовать одной записи в таблице базы данных. Теперь подробнее по каждому полю:**

*  ## title

    * *Это поле типа CharField, которое используется для хранения коротких строковых данных. В данном случае, это может быть имя человека или его заголовок. Максимальная длина строки — 255 символов.

* *<h2>content:</h2>*

    * *Поле типа TextField, предназначено для хранения длинного текста, например, биографии или описания. Атрибут blank=True означает, что поле может быть пустым (необязательное для заполнения).*

* *<h2>photo:</h2>*

    * *Поле типа ImageField, которое хранит загруженные изображения. Атрибут upload_to="photos/%Y/%m/%d/" указывает, что изображение будет сохранено в папке photos, с разбиением по годам, месяцам и дням загрузки (например, photos/2024/10/05/).*

* *<h2>time_create:</h2>*


    * *Поле типа DateTimeField, которое автоматически сохраняет дату и время создания записи. Атрибут auto_now_add=True означает, что значение будет установлено один раз при создании объекта.*

* *<h2>time_update:</h2>*

    * *Поле типа DateTimeField, которое обновляется автоматически при каждом изменении записи. Атрибут auto_now=True устанавливает текущие дату и время при каждом обновлении записи.*

* *<h2>is_published:</h2>*

    * *Поле типа BooleanField, которое хранит логическое значение (True или False). По умолчанию (default=True), запись считается опубликованной.*


**Этот класс создаст таблицу в базе данных с указанными полями и будет использоваться для работы с данными о людях.**

***Сейчас нам нужно сделать настройку для поле photo Она будет хранить путь к файлу в таблице базы данных. И чтобы Django  имела возможность автоматически выполнять загрузки графических файлов и формировать к нему путь, необходимо определить и настроить 2 спейциальные константы.***

***Для того чтобы поле photo в модели People корректно работало, нужно настроить константы MEDIA_ROOT и MEDIA_URL в файле настроек Django (settings.py). Эти константы указывают, где будут храниться загружаемые файлы и по какому URL они будут доступны.***

* 1. ***MEDIA_ROOT - Это абсолютный путь на сервере, куда будут сохраняться все загруженные файлы. Обычно эта директория не является доступной напрямую через веб, так как её основное предназначение — хранение данных. Django автоматически сохраняет файлы в эту папку при загрузке через модели, формы или другие механизмы.***

* 2. ***MEDIA_URL - Это URL, по которому пользователи смогут получить доступ к загруженным файлам через веб-браузер. Эта настройка указывает на веб-адрес, по которому медиа-файлы будут доступны для отображения на сайте. Обычно MEDIA_URL привязан к директории, заданной в MEDIA_ROOT, но через URL-адрес.***

***Открываем файл settings.py. И в конце данного файла мы добавим описание этих двух констант.***
```
import os

MEDIA_ROOT = os.path.join(BASE_DIR, "media")
MEDIA_URL = "/media/"
```

***Так же импортируем модуль os***

***Здесь BASE_DIR — это корневая директория проекта, а 'media' — папка, в которой будут храниться все загружаемые файлы. Эта папка может находиться где угодно на сервере, но обычно её располагают в корне проекта для удобства.***

***Здесь /media/ — это часть URL, которая будет добавляться к имени файла для доступа к загруженному контенту.***

***
***И в процессе отладки сйта, когда мы используем отладочный веб-сервер, нам нужно с эмулировать работу реального сервера для получения ранее загруженных фалов и передачи их нашему приложению. Для этого мы открываем файл coolsite/urls.py и внем пропишем дополнительную строчку.***
```
from django.conf.urls.static import static
from django.conf import settings


if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```

***И так в режиме отладки, когда DEBUG = True мы к паршрутам что ниже...***
```
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('people.urls'))
]
```
***Добавляем еще один маршрут для статических данных, графических файлов. Указываем данный URL settings.MEDIA_URL И затем корнивую папку где будут находится файлы.***
***
*Важно. Все это делаем только в отладочном режиме. На реальных серверах этот процесс как правило уже настоен и нам ничего дополнительно делать не неужно.*
***
***Теперь проверяем что в нашем фале coolsite/settings.py пораметр конфигурации DEBUG установлен в значение True***

***Теперь наша модель в файле models.py готова полностью и на основе этой моделе мы можем создать таблицу в базе данных. Для этого в Django и не только в нем существуют механизмы известные как создание и выполнение миграций для Баз-Данных. И что такое миграции ? это модули языка Python где описаны наборы команд на уровне ORM интерфейса для созданий таблиц определенных структур. При выполнении файл миграции в базе данных автоматически создаются новые или изменяются прежние таблицы а так же связи между ними.***
***
**Каждый файл миграции помещается в папку people/migrations. Пока в этой папки есть только один файл __ init __.py. НА основе этих фалов миграции и создается структура таблиц в нашей базе-данных. Причем каждый новый файл миграции описывает лишь изменения которые произошли в структурах таблицы с прошлого раза и их можно воспринимать как контроллера версии и благодоря этому мы всегда можем откатится к предыдущей структуре и продолжить работать с прежней  версии структур и связи между таблицами. Конечно при разработке сайтов структуру таблицы и их связи лучше продумывать заранее и потом не менять, Так как любое изменгение влияет на программный код и уже точно придется создавать очередную миграцию для обнавления базы даных. В учебных целях мы разберем как изменять структуру таблиц но на практике этого лучше избегать.**
***

***И так у нас нет ни одной миграции и папке кроме __ init __.py но это не  файл миграции. Создадим файл миграци! Находясь в корневом каталоге нгашего проекта мы выполним такую команду.***
```
(venv) PS D:\My Dream\virtual environment\coolsite> python manage.py makemigrations
```
**В данном случае у нас вышла ошибка потому что не установлен Pillow который необходим для работы с полем photo в models.py**
```
SystemCheckError: System check identified some issues:

ERRORS:
people.People.photo: (fields.E210) Cannot use ImageField because Pillow is not installed.
        HINT: Get Pillow at https://pypi.org/project/Pillow/ or run command "python -m pip install Pillow".
```
***Установим эго***
```
(venv) PS D:\My Dream\virtual environment\coolsite> python -m pip install Pillow
```
***Теперь снва совершаем миграцию***
```
(venv) PS D:\My Dream\virtual environment\coolsite> python manage.py makemigrations
```
***Все теперь файл миграции у нас появился и распологается по адресу people/migrations/0001_initial.py. это обычный python файл который служит чтоб создавать таблицы в базе-данных. И еще мы выполним запрос чтобы посмотреть на SQL запрос который будет выполнин для того чтобы создать эту таблицу***
```
(venv) PS D:\My Dream\virtual environment\coolsite> python manage.py sqlmigrate people 0001

BEGIN;
--
-- Create model People
--
CREATE TABLE "people_people" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(255) NOT NULL, "content" text NOT NULL, "photo" varchar(100) NOT NULL, "time_create" datetime NOT NULL, "time_update" datetime NOT NULL, "is_published" bool NOT NULL);
COMMIT;
```
***И теперь выполним до конца миграцию и создадим таблицу в базе данных***
```
(venv) PS D:\My Dream\virtual environment\coolsite> python manage.py migrate               
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, people, sessions
Running migrations:
  Applying people.0001_initial... OK
```

***И так же можем посмотреть что после выполнения миграции у нас в приложении SQLiteStudio появилось 11 полей в которых находитсмя и наше поле people_peolpe в котором нет ничего и так же можено посмотреть нашу структутру базы-данных которую мы прописали перед миграцией.***

***Еще бывает так что возникает некая ошибка и ничего не помогает, в таких случаях помогает очистеть кеш***
```
>>> python manage.py migrate --run-syncdb

```







