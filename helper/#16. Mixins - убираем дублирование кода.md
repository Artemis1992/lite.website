### Теперь мы вынесем общий код из классов представлений, которые находятся в файле ```views.py```. У нас есть следующие классы:

* ```class ShowPost(DetailView)```

* ```class PeopleHome(ListView)```

* ```class PeopleCategory(ListView)```

* ```class AddPage(CreateView)```

**Мы создадим отдельный класс, который будет называться ```DataMixin```. Название "Mixin" происходит из английского языка и означает "примесь". Если вы знакомы с объектно-ориентированным программированием, то, вероятно, знаете, что такое mixin и для чего он используется. Но давайте сделаем небольшую ремарку и рассмотрим некоторые важные моменты.**

### Зачем нужны миксины?
**Миксины были придуманы для обеспечения единообразного подхода к работе с объектами. Например, представьте, что вы разрабатываете интернет-магазин. Для каждого товара нужно определить стандартный набор свойств:**

* ```Идентификатор```
* ```Габариты```
* ```Вес```
* ```Цена```

**Для физических товаров это имеет смысл: они обладают весом, габаритами, ценой и идентификатором. Но для цифровых товаров (например, электронных книг или приложений для смартфонов) такие свойства, как габариты и вес, не применимы. Однако система магазина должна обращаться к этим свойствам, даже если их значения отсутствуют.  Как можно решить эту задачу?**

### **Решение через базовый класс(Писать данный класс не надо, это пример)**

**Мы можем создать базовый класс ```Goods```, где будут прописаны методы для работы со стандартными свойствами:**
```
class Goods:
    def getWeight(self):
        return self.weight

    def getPrice(self):
        return self.price
```
**Затем для каждого товара создается класс, наследующийся от ```Goods```, и можно использовать методы, чтобы получить свойства. Но если у нас сложная иерархия объектов, это решение становится неэффективным.**

**Каждый раз придется прописывать одни и те же методы в различных классах, что ведет к дублированию кода. Чтобы этого избежать, можно использовать миксины.**

### Как это выглядит в проекте?

**Рассмотрим текущую структуру представлений в нашем проекте:**


```
DataMixin | 	ListView    |	CreateView  | DetailView
          |    PeopleHome	|    AddPage	|  ShowPost
```
**Классы ```PeopleHome```, ```AddPage``` и ```ShowPost``` наследуются от своих базовых классов (```ListView```, ```CreateView```, ```DetailView```), которые мы создали ранее. Теперь мы добавим к ним общий базовый класс ```DataMixin```.**

***Пример:***
```
class PeopleHome(DataMixin, ListView):
    ...
```
### Почему миксин прописывается первым?

**В Python порядок наследования имеет значение. Класс, указанный первым, обрабатывается в первую очередь. Поэтому атрибуты из ```DataMixin``` будут использованы при создании объекта класса ```PeopleHome```. Если одинаковые атрибуты присутствуют и в ```DataMixin```, и в ```ListView```, то приоритет будут иметь атрибуты из ```DataMixin```.**

### Устраняем дублирование кода

**Сейчас в каждом классе представлений используется метод ```get_context_data()```, где повторяются одни и те же строки. Например:**
```
context = super().get_context_data(**kwargs)
context['title'] = 'Категория - ' + str(context['posts'][0].cat)
context['menu'] = menu
context['cat_selected'] = context['posts'][0].cat_id
```
**Чтобы убрать это дублирование, мы вынесем общий код в миксин ```DataMixin``` и подключим его ко всем представлениям.**

**Таким образом, мы добьемся более чистого и понятного кода.**

### Оптимизация кода: вынос общего функционала в миксин

**Для начала создадим класс ```DataMixin```, который будет содержать общий код, используемый в наших классах представлений. В Django принято выносить вспомогательные классы в отдельные файлы. Мы создадим файл ```utils.py``` в приложении ```people``` и пропишем там необходимую логику.**

## Шаг 1. Перенос коллекции menu в ```utils.py``` прежнюю удаляем.
```
menu = [
    {"title": "О сайте", "url_name": "about"},
    {"title": "Добавить статью", "url_name": "add_page"},
    {"title": "Обратная связь", "url_name": "contact"},
    {"title": "Войти", "url_name": "login"},
]
```
**Эта коллекция будет использоваться для формирования меню, чтобы избежать дублирования кода в разных местах.**

## Шаг 2. Создание класса ```DataMixin```

```
from .models import Category

class DataMixin:
    def get_user_context(self, **kwargs):
        context = kwargs
        cats = Category.objects.all()
        context['menu'] = menu
        context['cats'] = cats
        if 'cat_selected' not in context:
            context['cat_selected'] = 0
        return context
```
Объяснение:

1. ```get_user_context:```

    * **Этот метод создает общий контекст для шаблонов.**
    
    * **В него передаются параметры (```kwargs```), которые дополнительно обрабатываются.**

2. **Формирование списка категорий (```cats```):**

    * ```cats = Category.objects.all()``` **загружает все категории из модели ```Category```.**

3. **Добавление меню и категорий в контекст:**

    * ```context['menu'] = menu``` **добавляет коллекцию меню.**
    
    * ```context['cats'] = cats``` **добавляет категории.**
  
4. **Установка значения по умолчанию для cat_selected:**

    * **Если в ```kwargs``` нет ключа ```'cat_selected'```, то он добавляется со значением ```0```.**

5. **Возврат контекста:**

    * **Контекст возвращается для дальнейшего использования в шаблонах.**
***
## Шаг 3. Настройка шаблона для использования нового контекста

**Ранее для вывода категорий в шаблоне использовался пользовательский тег ```show_categories```. Мы заменим его на прямую работу с коллекцией ```cats```, передаваемой в контексте через ```DataMixin```.**

**Пример изменения шаблона ```base.html```:**
```
        {% for c in cats %}
            {% if c.pk == cat_selected %}
                <li class="selected">{{ c.name }}</li>
            {% else %}
                <li><a href="{{ c.get_absolute_url }}">{{ c.name }}</a></li>
            {% endif %}
        {% endfor %}
```
*Объяснение:*

* **Теперь категории выводятся через список ```cats```, который передается в контекст через ```DataMixin```.**

* **Это избавляет нас от необходимости использовать пользовательский тег ```show_categories```.**
  
***
## Шаг 4. Подключение ```DataMixin``` и удаление дублирования в коде

 **Импортируем нужные модули и классы: В начале файла ```views.py``` добавляем импорт:**
```
from .utils import DataMixin
```
**Таким образом, мы подключаем ```utils``` и все, что в нем прописано, а также класс ```DataMixin```.**

**Класс ```PeopleHome```:**
```
class PeopleHome(DataMixin, ListView):
    model = People
    template_name = "people/index.html"  # Указываем существующий шаблон.
    context_object_name = "posts"        # Явно указываем posts для использования в шаблоне.

    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # Базовый контекст от родительского класса.
        c_def = self.get_user_context(title='Главная страница')  # Добавляем данные из DataMixin.
        return dict(list(context.items()), list(c_def.items()))

    def get_queryset(self):
        return People.objects.filter(is_published=True)  # Фильтруем опубликованные записи.
```
**Класс ```ShowPost```:**
```
class ShowPost(DataMixin, DetailView):
    model = People
    template_name = "people/post.html"
    slug_url_kwarg = "post_slug"
    context_object_name = 'post'

    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # Базовый контекст.
        c_def = self.get_user_context(title=context['post'])  # Добавляем данные из DataMixin.
        return dict(list(context.items()) + list(c_def.items()))  # Объединяем словари.
```
**Класс ```PeopleCategory```:**
```
class PeopleCategory(DataMixin, ListView):
    model = People
    template_name = 'people/index.html'
    context_object_name = 'posts'

    def get_queryset(self):
        return People.objects.filter(cat__slug=self.kwargs['cat_slug'], is_published=True)

    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # Базовый контекст.
        c_def = self.get_user_context(
            title="Категория - " + str(context["posts"][0].cat),
            cat_selected=context['posts'][0].cat_id
        )
        # Объединяем словари
        return {**context, **c_def}
```
**Класс ```AddPage```:**
```
class AddPage(DataMixin, CreateView):
    form_class = AddPostForm
    template_name = "people/addpage.html"

    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # Базовый контекст.
        c_def = self.get_user_context(title='Добавление статьи')  # Добавляем данные из DataMixin.
        return {**context, **c_def}  # Объединяем словари.
```
***Объяснение процесса:***

1. **Почему мы используем ```self.get_user_context```:**

    **Метод ```get_user_context``` доступен благодаря наследованию от ```DataMixin```. Когда создается объект класса (например, ```PeopleHome```), мы можем вызывать методы базового класса через ```self```.**

2. **Передача параметров в ```get_user_context```:**

    **Мы передаем именованные параметры, такие как ```title```, чтобы в ```context = kwargs``` в ```utils.py``` автоматически сформировался словарь с ключами и значениями, необходимыми для общего контекста.**

3. **Объединение словарей:**

    **Два словаря — базовый контекст (```context```) и дополнения из ```DataMixin``` (```c_def```) — объединяются с помощью:**
```{**context, **c_def}```

4. **Устранение дублирования:**

    **Вместо повторения одинаковых строк в каждом классе (например, ```context['menu'] = menu```), общая логика вынесена в ```DataMixin```. Теперь код стал чище и легче для поддержки.**

5. **Запуск и тестирование:**
    
    **После внесенных изменений необходимо запустить тестовый веб-сервер из терминала и проверить, что страницы отображаются корректно.**

***Теперь сайт работает как до внедрения Mixin, но код стал более структурированным и чистым.***

***

## Использование ```LoginRequiredMixin``` в Django

**```LoginRequiredMixin``` – это стандартный ```Mixin``` в Django, который ограничивает доступ к странице для неавторизованных пользователей. Этот ```Mixin``` можно использовать в классах представлений (CBV).**

**Импорт ```LoginRequiredMixin```**

**Для использования необходимо импортировать ```LoginRequiredMixin```:**
```
from django.contrib.auth.mixins import LoginRequiredMixin
```
**Добавление ```LoginRequiredMixin``` в класс**

**Пример использования с классом представления:**
```
class AddPage(LoginRequiredMixin, DataMixin, CreateView):
    ...

```
**После добавления миксина, при попытке неавторизованного пользователя перейти на страницу, будет отображено исключение 404:**
```
Page not found (404)
Request Method:	GET
Request URL:	http://127.0.0.1:8000/accounts/login/?next=/addpage/
```

**Настройка перенаправления для неавторизованных пользователей**

**Чтобы сделать поведение более дружелюбным, можно настроить перенаправление. Для этого добавляем атрибут ```login_url```:**
```
class AddPage(LoginRequiredMixin, DataMixin, CreateView):
    form_class = AddPostForm
    template_name = "people/addpage.html"
    login_url = '/admin/'
```
**Теперь неавторизованный пользователь будет перенаправляться на страницу ```/admin/``` для входа.**

**Использование ```reverse_lazy``` для гибкости**

**Жестко прописывать URL-адреса – не лучшая практика. Вместо этого используем функцию ```reverse_lazy```:**
```
from django.urls import reverse_lazy

class AddPage(LoginRequiredMixin, DataMixin, CreateView):
    form_class = AddPostForm
    template_name = "people/addpage.html"
    success_url = reverse_lazy("home")
    login_url = reverse_lazy("home")
```
**Если требуется показать ошибку 403 (Forbidden), используем атрибут ```raise_exception```:**
```
class AddPage(LoginRequiredMixin, DataMixin, CreateView):
    raise_exception = True
```
***

### Ограничение доступа для функций представлений

**Для функций представлений используется декоратор ```@login_required```:**
```
from django.contrib.auth.decorators import login_required

@login_required
def about(request):
    return render(request, 'people/about.html', {"menu": menu, 'title': 'О сайте'})
```
**Если пользователь не авторизован, при попытке доступа к странице будет выдано сообщение:**
```Page not found (404)```
**Можно пока что убрать данный декоратор мы его разобрали чтобы было общее понимание**

***

### Скрытие пункта "Добавить статью" для неавторизованных пользователей

**Чтобы неавторизованным пользователям не отображался пункт "Добавить статью", изменяем логику формирования меню. В файле ```utils.py``` в классе ```DataMixin``` добавляем следующий код:**
```
class DataMixin:
    def get_user_context(self, **kwargs):
        context = kwargs
        cats = Category.objects.all()
        
        user_menu = menu.copy()
        if not self.request.user.is_authenticated:
            user_menu.pop(1)  # Удаляем пункт "Добавить статью"
        
        context['menu'] = user_menu
        context['cats'] = cats
        if 'cat_selected' not in context:
            context['cat_selected'] = 0
        return context
```
**Теперь в зависимости от авторизации пользователя пункт "Добавить статью" будет отображаться или скрываться.**

***

### Изменение шаблона ```base.html```

**Для отображения главного меню изменяем шаблон ```base.html```. Удаляем строку:**
```
{% show_menu %}
```
**И заменяем ее следующим кодом:**
```
<!-- Блок главного меню -->
{% block mainmenu %}
    <div class="header">
        <ul id="mainmenu" class="mainmenu">
            <!-- Логотип -->
            <li class="logo"><a href="{% url "home" %}"><div class="logo"></div></a></li>

            {% for m in menu %}
                {% if not forloop.last %}
                    <li><a href="{% url m.url_name %}">{{ m.title }}</a></li>
                {% else %}
                    <li class="last"><a href="{% url m.url_name %}">{{ m.title }}</a></li>
                {% endif %}
            {% endfor %}
        </ul>
    </div>
{% endblock %}
```
**Теперь для неавторизованных пользователей пункт "Добавить статью" не будет отображаться, а для авторизованных – появится.**

## Итоги

1. **Для классов представлений используется ```LoginRequiredMixin```, а для функций – декоратор ```@login_required```.**

2. **Меню динамически изменяется в зависимости от состояния авторизации пользователя.**
3. **Использование ```reverse_lazy``` позволяет избежать жесткой привязки к URL.**
4. **Код стал более удобным и логичным для пользователей.**

## Улучшение: Скрытие пустых рубрик в списке категорий

**Изменения в коде:**

**Обновление коллекции ```cats``` в ```DataMixin```: Ранее рубрики извлекались с помощью команды:**
```
cats = Category.objects.all()
```
**Теперь мы используем аннотацию для добавления атрибута, подсчитывающего количество постов в рубрике:**
```
cats = Category.objects.annotate(Count('people'))
```
**Благодаря этому у каждого объекта ```Category``` появляется новое свойство ```people__count```, которое хранит количество постов, связанных с этой рубрикой.**

**Импортируем ```Count``` из Django ORM: В начало файла ```utils.py``` добавляем:**
```
from django.db.models import Count
```
**Изменения в шаблоне ```base.html```: В блоке, где выводятся рубрики, добавляем условие проверки, есть ли в рубрике посты:**

```
{% for c in cats %}
    {% if c.people__count > 0 %} <!-- Если в рубрике есть посты -->
        {% if c.pk == cat_selected %}
            <li class="selected">{{ c.name }}</li>
        {% else %}
            <li><a href="{{ c.get_absolute_url }}">{{ c.name }}</a></li>
        {% endif %}
    {% endif %}
{% endfor %}
```
**Что изменилось:**

* **Теперь рубрики, в которых нет ни одного поста, не отображаются в списке категорий на сайте.**

* **Это улучшает пользовательский интерфейс, исключая отображение "пустых" рубрик, которые могут вызывать неудобства.**
  
**Проверка:**

* **Обновляем сайт.**

* **В рубрике "Спортсменки", где нет ни одного поста, ссылка больше не отображается.**

* **Если добавить пост в эту рубрику, она снова появится в списке категорий.**

**Примечание:**

* **Для большего удобства можно в дальнейшем сделать вывод о пустых рубриках динамическим (например, показывать рубрики с подписью "Нет постов"), если это необходимо для UX.**







